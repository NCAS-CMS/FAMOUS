*IF DEF,C95_2A,OR,DEF,RECON,OR,DEF,UTILIO,OR,DEF,UTILHIST,OR,DEF,FLDIO     UIE3F404.37    
/* ******************************COPYRIGHT******************************   GTS0C400.1     
 * (c) CROWN COPYRIGHT 1995, METEOROLOGICAL OFFICE, All Rights Reserved.   GTS0C400.2     
 *                                                                         GTS0C400.3     
 * Use, duplication or disclosure of this code is subject to the           GTS0C400.4     
 * restrictions as set forth in the contract.                              GTS0C400.5     
 *                                                                         GTS0C400.6     
 *                Meteorological Office                                    GTS0C400.7     
 *                London Road                                              GTS0C400.8     
 *                BRACKNELL                                                GTS0C400.9     
 *                Berkshire UK                                             GTS0C400.10    
 *                RG12 2SZ                                                 GTS0C400.11    
 *                                                                         GTS0C400.12    
 * If no contract has been raised with this copy of the code, the use,     GTS0C400.13    
 * duplication or disclosure of it is strictly prohibited. Permission      GTS0C400.14    
 * to do so must first be obtained in writing from the Head of             GTS0C400.15    
 * Numerical Modelling at the above address.                               GTS0C400.16    
 * ******************************COPYRIGHT******************************   GTS0C400.17    
*/                                                                         GTS0C400.18    
#include <stdio.h>                                                         PORTIO2A.3     
#include <stdlib.h>                                                        PORTIO2A.4     
#include <string.h>                                                        PORTIO2A.5     
                                                                           RK151293.1     
*IF DEF,CRI_OPEN                                                           GBC6C404.14    
/* Declarations to use the pre-allocation via ialloc on Cray    */         GBC6C404.15    
/* Research Platforms                                           */         GBC6C404.16    
#include <unistd.h>                                                        GBC6C404.17    
#include <sys/wait.h>                                                      GBC6C404.18    
#include <sys/types.h>                                                     GBC6C404.19    
#include <sys/file.h>                                                      GBC6C404.20    
                                                                           GBC6C404.21    
#include <sys/statfs.h>                                                    GBC6C404.22    
#include <sys/fstyp.h>                                                     GBC6C404.23    
#include <sys/fsid.h>                                                      GBC6C404.24    
                                                                           GBC6C404.25    
*ENDIF                                                                     GBC6C404.26    
#include <errno.h>                                                         RK151293.2     
                                                                           RK151293.4     
                                                                           RK151293.5     
#include <time.h>                                                          AD100293.14    
*IF DEF,CRAY                                                               GBC0C402.1     
/* Read fortran.h to get Fortran Character stuff on Cray's */              GBC0C402.2     
#include <fortran.h>                                                       GPB0C305.10    
*ENDIF                                                                     GPB0C305.11    
*IF DEF,CRI_FFIO,OR,DEF,CRI_OPEN                                           GBC6C404.1     
/* Read Headers for FFIO */                                                GBC0C402.21    
#include <fcntl.h>                                                         GBC0C402.22    
#include <ffio.h>                                                          GBC0C402.23    
*ENDIF                                                                     GBC0C402.24    
                                                                           PORTIO2A.6     
     /* C language routines for portable version of UM */                  PORTIO2A.7     
     /*       Written by A.Dickinson 1/11/91           */                  PORTIO2A.8     
     /* Model    Modification history from version 3.0  */                 RS030293.247   
     /* version  Date                                   */                 RS030293.248   
     /* 3.1      15/01/93 Increase size of available    */                 RS030293.249   
     /*          unit nos. from 1-100 to 1-199.         */                 RS030293.250   
     /*          R.Rawlins                              */                 RS030293.251   
     /*                                                 */                 TS140793.1     
     /*          A range of C - Fortran interfaces      */                 TS140793.2     
     /*          provided via *DEFS C_LOW & C_LOW_U.    */                 TS140793.3     
     /*          See UM Doc Paper S5.                   */                 TS140793.4     
     /*                                                 */                 TS140793.5     
     /*          A.Dickinson 24/06/93                   */                 TS140793.6     
     /*                                                 */                 AD061193.3     
     /* 3.3      Error in dimension of array fno in     */                 AD061193.4     
     /*          routine get_file corrected. Change type*/                 AD061193.5     
     /*          in date_time to remove compilation     */                 AD061193.6     
     /*          warnings. A.Dickinson 06/11/93         */                 AD061193.7     
     /* 3.3       07/09/93 Set buffer in OPEN. R.Rawlins */                RK151293.6     
     /* 3.3      04/10/93 New routine FLUSH_BUFFER to   */                 RR041093.1     
     /*          force buffer write. R. Rawlins         */                 RR041093.2     
     /* 3.3       09/08/94 Include test in CLOSE to check*/                GRR1C304.1     
     /*           unit flag and by-pass close if unit    */                GRR1C304.2     
     /*           already closed or not yet opened.      */                GRR1C304.3     
     /*           Reset unit flag on normal close of     */                GRR1C304.4     
     /*           file. {close unit a then open unit b   */                GRR1C304.5     
     /*           then close unit a caused file pointer  */                GRR1C304.6     
     /*           for unit b to become unspecified.      */                GRR1C304.7     
     /*           R. Rawlins                             */                GRR1C304.8     
     /* 3.4      04/10/94 Improvement to code in getfile*/                 GTS2C304.1     
     /*                   Tracey Smith                  */                 GTS2C304.2     
  /* 3.5  23/03/95 Tidy up the interface between Fortran REALs */          GPB0C305.1     
  /*           and C float/double.                             */          GPB0C305.2     
  /*           Rename open and close to file_open + file_close */          GPB0C305.3     
  /*           T3D specific code for CHARACTER arguments       */          GPB0C305.4     
  /*           Change name of some routines for mpp code       */          GPB0C305.5     
  /*           Add routine FORT_GET_ENV to get environment     */          GPB0C305.6     
  /*           variables from Fortran                          */          GPB0C305.7     
  /*                Author : Paul Burton                       */          GPB0C305.8     
 /* 4.0 Error code argument added to setpos, close M.TURP */               GTD0C400.1     
                                                                           PORTIO2A.9     
   /*  Added perror call to BUFFIN and BUFFOUT */                          GGH0C400.1     
   /*  Gordon Henderson */                                                 GGH0C400.2     
  /* 4.1  11/04/96  FILE_OPEN: Check the return code from getenv    */     GPB0C401.1     
  /*                           and trap NULL                        */     GPB0C401.2     
  /*                FILE_CLOSE: Ditto                               */     GPB0C401.3     
  /*                GET_FILE: Checks getenv return code and if NULL */     GPB0C401.4     
  /*                          sets filename argument to blank       */     GPB0C401.5     
  /*                FORT_GET_ENV: Added code for T3D functionality  */     GPB0C401.6     
  /*      Paul Burton  */                                                  GPB0C401.7     
  /*                                                           */          GBC0C402.25    
  /*           Make the necessary changes to use FFIO and      */          GBC0C402.26    
  /*           character variables correctly on all Cray       */          GBC0C402.27    
  /*           Platforms.                                      */          GBC0C402.28    
  /*                                                           */          GBC0C402.29    
  /*                Bob Carruthers, Cray Research U.K.         */          GBC0C402.30    
  /*                                                            */         GBC6C404.2     
  /* 4.4  17/06/97  Modify the write/print statements to use    */         GBC6C404.3     
  /*                a standard mechanism, set up via a #define  */         GBC6C404.4     
  /*                statement                                   */         GBC6C404.5     
  /*                  Author: Bob Carruthers, Cray Research     */         GBC6C404.6     
  /*                                                            */         GBC6C404.7     
  /* 4.4  17/06/97  Add code to accept and use the current      */         GBC6C404.8     
  /*                Length for a dumpfile                       */         GBC6C404.9     
  /*                  Author: Bob Carruthers, Cray Research     */         GBC6C404.10    
  /*                                                            */         GBC6C404.11    
                                                                           GBC6C404.12    
                                                                           GBC6C404.13    
  /*           Changes to GET_FILE to allow unit numbers     */            UIE0C404.1     
  /*           greater > 100 to be used as enviroment        */            UIE0C404.2     
  /*           variables for filenames.     Ian Edmond       */            UIE0C404.3     
  /* 4.5  01/04/98  Assorted mods to the C code:                */         GPB0C405.1     
  /*                BUFFIN32: New routine added, and check that */         GPB0C405.2     
  /*                          unit is open added to BUFFO32     */         GPB0C405.3     
  /*                SETPOS32: New routines added for setting/   */         GPB0C405.4     
  /*                GETPOS32: reading file pointer for 32bit    */         GPB0C405.5     
  /*                          word files                        */         GPB0C405.6     
  /*                                                            */         GPB0C405.7     
  /*                Authors: Bob Carruthers & Paul Burton       */         GPB0C405.8     
  /*                                                            */         GPB0C405.9     
                                                                           GPB0C405.10    
  /*                                                            */         GBC2C405.1     
  /* 4.5  31/03/98  Modify various definitions to make porting  */         GBC2C405.2     
  /*                to platforms that fully support 32 and 64   */         GBC2C405.3     
  /*                integers easier.                            */         GBC2C405.4     
  /*                  Author: Bob Carruthers, Cray Research     */         GBC2C405.5     
  /*                                                            */         GBC2C405.6     
  /* 4.5  16/07/98  Add properties flag word for each unit -    */         GBC2C405.7     
  /*                initial use is to broadcasts in buffin for  */         GBC2C405.8     
  /*                the AC scheme.                              */         GBC2C405.9     
  /*                  Author: Bob Carruthers, Cray Research     */         GBC2C405.10    
  /*                                                            */         GBC2C405.11    
  /*                                                            */         GBC3C405.1     
  /* 4.5  17/08/98  Code to ensure that we do not over-index    */         GBC3C405.2     
  /*                character arrays in Fortran or C            */         GBC3C405.3     
  /*                  Author: Bob Carruthers, Cray Research     */         GBC3C405.4     
  /* 5.0  26/07/99  Fix error in declaration of fname in        */         PXPORTIO.1     
  /*                FILE_OPEN and FILE_CLOSE                    */         PXPORTIO.2     
  /*                Author: Paul Selwood                        */         PXPORTIO.3     
                                                                           GBC3C405.5     
*IF DEF,FRL8,OR,DEF,CRAY                                                   GBC0C402.3     
typedef double real;                                                       GPB0C305.13    
*IF DEF,INTLL                                                              PXPORTIO.21    
typedef long long integer;                                                 PXPORTIO.22    
*ELSE                                                                      PXPORTIO.23    
typedef long integer;                                                      PXPORTIO.24    
*ENDIF                                                                     PXPORTIO.25    
                                                                           PXPORTIO.26    
/* Fortran REAL is equivalent to C double */                               GPB0C305.14    
*ELSE                                                                      GPB0C305.15    
typedef float real;                                                        GPB0C305.16    
typedef int integer;                                                       GBC2C405.13    
/* Fortran REAL is equivalent to C float */                                GPB0C305.17    
*ENDIF                                                                     GPB0C305.18    
                                                                           GBC6C404.27    
/* Define the function that outputs the text string for         */         GBC6C404.28    
/* messages.  Note that the trailing newline character is       */         GBC6C404.29    
/* to be supplied by the print routine, and is no longer        */         GBC6C404.30    
/* in the string.  Similarly, leading new lines are now handled */         GBC6C404.31    
/* by the print routine - typically a newline is inserted for   */         GBC6C404.32    
/* each change of unit.                                         */         GBC6C404.33    
                                                                           GBC6C404.34    
*IF DEF,CRAY                                                               GBC2C405.14    
#define CALL_MESSAGE_PRINT(text) \                                         GBC6C404.36    
 PRINT_FROM_C(the_unit, _cptofcd(text, strlen(text)))                      GBC6C404.37    
*ELSE                                                                      GBC6C404.38    
#define CALL_MESSAGE_PRINT(text) fprintf(stdout, "%s\n", text);        \   PXPORTIO.19    
 fflush(stdout)                                                            PXPORTIO.20    
*ENDIF                                                                     GBC6C404.40    
                                                                           GBC6C404.41    
static char message[256];                                                  GBC6C404.42    
                                                                           GBC6C404.43    
#define MAX_UNITS 200                                                      GBC6C404.44    
                                                                           GBC6C404.45    
integer *the_unit;                                                         GBC6C404.46    
                                                                           GBC6C404.47    
                                                                           GPB0C305.20    
*IF DEF,CRI_FFIO                                                           GBC0C402.31    
int fd[MAX_UNITS];                                                         GBC6C404.48    
*ELSE                                                                      GBC0C402.33    
FILE *pf[MAX_UNITS]=                                                       GBC6C404.49    
                     {NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.50    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.51    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.52    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.53    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.54    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.55    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.56    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.57    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.58    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.59    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.60    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.61    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.62    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.63    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.64    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.65    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.66    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.67    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,   GBC6C404.68    
                      NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL    GBC6C404.69    
                     };                                                    GBC6C404.70    
*ENDIF                                                                     GBC0C402.35    
                                                                           GBC6C404.73    
static integer io_position[MAX_UNITS];                                     GBC6C404.74    
*IF DEF,CRI_OPEN                                                           GBC6C404.75    
                                                                           GBC6C404.76    
integer file_size[MAX_UNITS] =                                             GBC6C404.77    
                     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.78    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.79    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.80    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.81    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.82    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.83    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.84    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.85    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC6C404.86    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};            GBC6C404.87    
                                                                           GBC6C404.88    
struct statfs stats;                                                       GBC6C404.89    
char buf[FSTYPSZ];                                                         GBC6C404.90    
                                                                           GBC6C404.91    
*ENDIF                                                                     GBC6C404.92    
int open_flag[MAX_UNITS] =                                                 GBC6C404.71    
                     {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             GBC6C404.72    
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.254   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.255   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.256   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.257   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.258   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.259   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.260   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,             RS030293.261   
                      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};            RS030293.262   
                                                                           GBC2C405.15    
/* Unit properies table - one word per unit, one bit per                   GBC2C405.16    
   property at present */                                                  GBC2C405.17    
                                                                           GBC2C405.18    
integer file_properties[MAX_UNITS] =                                       GBC2C405.19    
                     {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.20    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.21    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.22    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.23    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.24    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.25    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.26    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.27    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,             GBC2C405.28    
                      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};            GBC2C405.29    
                                                                           GBC2C405.30    
/* Define the bits used in the properies table */                          GBC2C405.31    
                                                                           GBC2C405.32    
#define BCAST 1                                                            GBC2C405.33    
                                                                           GBC2C405.34    
*IF DEF,C_LOW                                                              GBC2C405.35    
extern void clear_unit_bcast_flag();                                       GBC2C405.36    
*ELSEIF DEF,C_LOW_U                                                        GBC2C405.37    
extern void clear_unit_bcast_flag_();                                      GBC2C405.38    
*ELSE                                                                      GBC2C405.39    
extern void CLEAR_UNIT_BCAST_FLAG();                                       GBC2C405.40    
*ENDIF                                                                     GBC2C405.41    
                                                                           GBC2C405.42    
                                                                           PORTIO2A.16    
void                                                                       GBC2C405.43    
*IF DEF,MPP                                                                GPB0C305.168   
*IF DEF,C_LOW                                                              GPB0C305.169   
buffin_single                                                              GPB0C305.170   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.171   
buffin_single_                                                             GPB0C305.172   
*ELSE                                                                      GPB0C305.173   
BUFFIN_SINGLE                                                              GPB0C305.174   
*ENDIF                                                                     GPB0C305.175   
*ELSE                                                                      GPB0C305.176   
*IF DEF,C_LOW                                                              TS140793.7     
buffin                                                                     TS140793.8     
*ELSEIF DEF,C_LOW_U                                                        TS140793.9     
buffin_                                                                    TS140793.10    
*ELSE                                                                      TS140793.11    
BUFFIN                                                                     TS140793.12    
*ENDIF                                                                     TS140793.13    
*ENDIF                                                                     GPB0C305.177   
(unit, array, maxlen, length, status)                                      TS140793.14    
integer *unit;      /* Fortran unit                         */             GPB0C305.21    
*IF DEF,CRI_FFIO                                                           GBC0C402.36    
char array[];       /* Array into which data is read        */             GBC0C402.37    
*ELSE                                                                      GBC0C402.38    
real array[];       /* Array into which data is read        */             GPB0C305.22    
*ENDIF                                                                     GBC0C402.39    
integer *maxlen;    /* Number of real numbers to be read    */             GPB0C305.23    
integer *length;    /* Number of real numbers actually read */             GPB0C305.24    
real *status;       /* Return code                          */             GPB0C305.25    
{                                                                          PORTIO2A.23    
int k;                                                                     PORTIO2A.24    
  the_unit=unit;                                                           GBC6C404.93    
                                                                           PORTIO2A.25    
*IF DEF,CRI_FFIO                                                           GBC0C402.40    
  if(open_flag[*unit]== 0){                                                GBC0C402.41    
    k = ffread(fd[*unit], array, sizeof(real)*(*maxlen));                  GBC0C402.42    
    *length = k/sizeof(real);                                              GBC0C402.43    
                                                                           GBC0C402.44    
        *status=-1.0;                                                      GBC0C402.45    
    if(k == -1)                                                            GBC0C402.46    
    {                                                                      GBC0C402.47    
      k=errno;                                                             GBC0C402.48    
      if(k != ENOTWELLFORMED)                                              GBC6C404.94    
      {                                                                    GBC6C404.95    
        perror("\nBUFFIN: Read Failed");                                   GBC6C404.96    
        sprintf(message,                                                   GBC6C404.97    
         "BUFFIN: C I/O Error - Return code = %d", k);                     GBC6C404.98    
        CALL_MESSAGE_PRINT(message);                                       GBC6C404.99    
      }                                                                    GBC6C404.100   
      *status=5.0;                                                         GBC6C404.101   
      if(k == FFEOF || k == FFEOD)                                         GBC0C402.52    
      {                                                                    GBC0C402.53    
        *status=0.0;                                                       GBC0C402.54    
      }                                                                    GBC0C402.55    
      if(k == FFEOR)                                                       GBC0C402.56    
      {                                                                    GBC0C402.57    
        *status=1.0;                                                       GBC0C402.58    
      }                                                                    GBC0C402.59    
      if(k == FFERR)                                                       GBC0C402.60    
      {                                                                    GBC0C402.61    
        *status=2.0;                                                       GBC0C402.62    
      }                                                                    GBC0C402.63    
      if(k == ENOTWELLFORMED)                                              GBC6C404.102   
      {                                                                    GBC6C404.103   
        *status=4.0;                                                       GBC6C404.104   
      }                                                                    GBC6C404.105   
    }                                                                      GBC0C402.64    
   }                                                                       GBC0C402.65    
*ELSE                                                                      GBC0C402.66    
  if(open_flag[*unit]== 0){                                                PORTIO2A.26    
    *length = fread(array,sizeof(real),*maxlen,pf[*unit]);                 GPB0C305.26    
                                                                           PORTIO2A.28    
        *status=-1.0;                                                      PORTIO2A.29    
        k=feof(pf[*unit]);                                                 PORTIO2A.30    
    if(k != 0)                                                             TS210793.1     
    {                                                                      TS210793.2     
      perror("\nBUFFIN: Read Failed");                                     GBC6C404.106   
      sprintf(message,                                                     GBC6C404.107   
       "BUFFIN: C I/O Error - Return code = %d", k);                       GBC6C404.108   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.109   
      *status=0.0;                                                         TS210793.5     
    }                                                                      TS210793.6     
        k=ferror(pf[*unit]);                                               PORTIO2A.32    
    if(k != 0)                                                             TS210793.7     
    {                                                                      TS210793.8     
      perror("\nBUFFIN: Read Failed");                                     GBC6C404.110   
      sprintf(message,                                                     GBC6C404.111   
       "BUFFIN: C I/O Error - Return code = %d", k);                       GBC6C404.112   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.113   
      *status=1.0;                                                         TS210793.11    
    }                                                                      TS210793.12    
   }                                                                       PORTIO2A.34    
*ENDIF                                                                     GBC0C402.67    
   else                                                                    PORTIO2A.35    
        *status=3.0;                                                       PORTIO2A.36    
                                                                           PORTIO2A.37    
    io_position[*unit]=io_position[*unit]+*length;                         GBC6C404.114   
}                                                                          PORTIO2A.38    
                                                                           PORTIO2A.39    
void                                                                       GBC2C405.44    
*IF DEF,MPP                                                                GPB0C305.178   
*IF DEF,C_LOW                                                              GPB0C305.179   
buffout_single                                                             GPB0C305.180   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.181   
buffout_single_                                                            GPB0C305.182   
*ELSE                                                                      GPB0C305.183   
BUFFOUT_SINGLE                                                             GPB0C305.184   
*ENDIF                                                                     GPB0C305.185   
*ELSE                                                                      GPB0C305.186   
*IF DEF,C_LOW                                                              TS140793.15    
buffout                                                                    TS140793.16    
*ELSEIF DEF,C_LOW_U                                                        TS140793.17    
buffout_                                                                   TS140793.18    
*ELSE                                                                      TS140793.19    
BUFFOUT                                                                    TS140793.20    
*ENDIF                                                                     TS140793.21    
*ENDIF                                                                     GPB0C305.187   
(unit, array, maxlen, length, status)                                      TS140793.22    
integer *unit;      /* Fortran unit                            */          GPB0C305.27    
*IF DEF,CRI_FFIO                                                           GBC0C402.68    
char array[];       /* Array from which data is written        */          GBC0C402.69    
*ELSE                                                                      GBC0C402.70    
real array[];       /* Array from which data is written        */          GPB0C305.28    
*ENDIF                                                                     GBC0C402.71    
integer *maxlen;    /* Number of real numbers to be written    */          GPB0C305.29    
integer *length;    /* Number of real numbers actually written */          GPB0C305.30    
real *status;       /* Return code                             */          GPB0C305.31    
{                                                                          PORTIO2A.46    
int k;                                                                     PORTIO2A.47    
  the_unit=unit;                                                           GBC6C404.115   
                                                                           PORTIO2A.48    
*IF DEF,CRI_FFIO                                                           GBC0C402.72    
  if(open_flag[*unit]== 0){                                                GBC0C402.73    
    k = ffwrite(fd[*unit], array, sizeof(real)*(*maxlen));                 GBC0C402.74    
    *length = k/sizeof(real);                                              GBC0C402.75    
                                                                           GBC0C402.76    
        *status=-1.0;                                                      GBC0C402.77    
    if(k == -1)                                                            GBC0C402.78    
    {                                                                      GBC0C402.79    
      k=errno;                                                             GBC0C402.80    
      if(k != ENOTWELLFORMED)                                              GBC6C404.116   
      {                                                                    GBC6C404.117   
        perror("\nBUFFOUT: Write Failed");                                 GBC6C404.118   
        sprintf(message,                                                   GBC6C404.119   
         "BUFFOUT: C I/O Error - Return code = %d", k);                    GBC6C404.120   
        CALL_MESSAGE_PRINT(message);                                       GBC6C404.121   
      }                                                                    GBC6C404.122   
      *status=5.0;                                                         GBC6C404.123   
      if(k == FFEOF || k == FFEOD)                                         GBC0C402.84    
      {                                                                    GBC0C402.85    
        *status=0.0;                                                       GBC0C402.86    
      }                                                                    GBC0C402.87    
      if(k == FFEOR)                                                       GBC0C402.88    
      {                                                                    GBC0C402.89    
        *status=1.0;                                                       GBC0C402.90    
      }                                                                    GBC0C402.91    
      if(k == FFERR)                                                       GBC0C402.92    
      {                                                                    GBC0C402.93    
        *status=2.0;                                                       GBC0C402.94    
      }                                                                    GBC0C402.95    
      if(k == ENOTWELLFORMED)                                              GBC6C404.124   
      {                                                                    GBC6C404.125   
        *status=4.0;                                                       GBC6C404.126   
      }                                                                    GBC6C404.127   
    }                                                                      GBC0C402.96    
   }                                                                       GBC0C402.97    
*ELSE                                                                      GBC0C402.98    
  if(open_flag[*unit]== 0){                                                PORTIO2A.49    
    *length = fwrite(array,sizeof(real),*maxlen,pf[*unit]);                GPB0C305.32    
                                                                           PORTIO2A.51    
        *status=-1.0;                                                      PORTIO2A.52    
        k=feof(pf[*unit]);                                                 PORTIO2A.53    
    if(k != 0)                                                             TS210793.13    
    {                                                                      TS210793.14    
      perror("\nBUFFOUT: Write Failed");                                   GBC6C404.128   
      sprintf(message,                                                     GBC6C404.129   
       "BUFFOUT: C I/O Error - Return code = %d", k);                      GBC6C404.130   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.131   
      *status=0.0;                                                         TS210793.17    
    }                                                                      TS210793.18    
        k=ferror(pf[*unit]);                                               PORTIO2A.55    
    if(k != 0)                                                             TS210793.19    
    {                                                                      TS210793.20    
      perror("\nBUFFOUT: Write Failed");                                   GBC6C404.132   
      sprintf(message,                                                     GBC6C404.133   
       "BUFFOUT: C I/O Error - Return code = %d", k);                      GBC6C404.134   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.135   
      *status=1.0;                                                         TS210793.23    
    }                                                                      TS210793.24    
   }                                                                       PORTIO2A.57    
*ENDIF                                                                     GBC0C402.99    
   else                                                                    PORTIO2A.58    
        *status=3.0;                                                       PORTIO2A.59    
                                                                           PORTIO2A.60    
    io_position[*unit]=io_position[*unit]+*length;                         GBC6C404.136   
}                                                                          PORTIO2A.61    
                                                                           PORTIO2A.62    
void                                                                       GBC2C405.45    
*IF DEF,MPP                                                                GPB0C305.158   
*IF DEF,C_LOW                                                              GPB0C305.159   
setpos_single                                                              GPB0C305.160   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.161   
setpos_single_                                                             GPB0C305.162   
*ELSE                                                                      GPB0C305.163   
SETPOS_SINGLE                                                              GPB0C305.164   
*ENDIF                                                                     GPB0C305.165   
*ELSE                                                                      GPB0C305.166   
*IF DEF,C_LOW                                                              TS140793.23    
setpos                                                                     TS140793.24    
*ELSEIF DEF,C_LOW_U                                                        TS140793.25    
setpos_                                                                    TS140793.26    
*ELSE                                                                      TS140793.27    
SETPOS                                                                     TS140793.28    
*ENDIF                                                                     TS140793.29    
*ENDIF                                                                     GPB0C305.167   
(unit, word_address,err)                                                   GTD0C400.2     
integer *unit;      /* Fortran unit                         */             GPB0C305.33    
integer *word_address; /* Number of words into file            */          GBC2C405.46    
integer *err;          /* Error checking, err = 0 no errors,               GBC2C405.47    
                                          err = 1 errors */                GBC2C405.48    
{                                                                          PORTIO2A.66    
int k;                                                                     PORTIO2A.67    
integer byte_address;                                                      GBC2C405.49    
  the_unit=unit;                                                           GBC6C404.137   
*IF DEF,CRI_FFIO                                                           GBC0C402.100   
                                                                           GBC0C402.101   
  if(open_flag[*unit]== 0){                                                GBC0C402.102   
    byte_address=(*word_address)*sizeof(real);                             GBC2C405.50    
    k = ffseek(fd[*unit], byte_address, SEEK_SET);                         GBC0C402.104   
    *err=0;                                                                GBC0C402.105   
    if(k < 0){                                                             GBC0C402.106   
      k=errno;                                                             GBC0C402.107   
      perror("\nSETPOS: Seek Failed");                                     GBC6C404.138   
      sprintf(message,                                                     GBC6C404.139   
       "SETPOS: Unit %d to Word Address %d Failed with Error Code %d",     GBC6C404.140   
       (int) *unit, (int) *word_address, k);                               GBC6C404.141   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.142   
      *err=1;                                                              GBC0C402.112   
      abort();                                                             GBC0C402.113   
    }                                                                      GBC0C402.114   
  }                                                                        GBC0C402.115   
*ELSE                                                                      GBC0C402.116   
                                                                           PORTIO2A.69    
    byte_address=(*word_address)*sizeof(real);                             GBC2C405.51    
    k = fseek(pf[*unit],byte_address,SEEK_SET);                            RK151293.126   
    *err = 0;                                                              GTD0C400.4     
    if(k!=0){                                                              PORTIO2A.72    
      perror("\nSETPOS: Seek Failed");                                     GBC6C404.143   
      sprintf(message,                                                     GBC6C404.144   
       "SETPOS: Unit %d to Word Address %d Failed with Error Code %d",     GBC6C404.145   
       (int) *unit, (int) *word_address, k);                               GBC6C404.146   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.147   
         *err = 1;                                                         GTD0C400.5     
         abort();                                                          PORTIO2A.76    
    }                                                                      PORTIO2A.77    
*ENDIF                                                                     GBC0C402.117   
   io_position[*unit]=*word_address;                                       GBC6C404.148   
                                                                           GBC6C404.149   
}                                                                          PORTIO2A.78    
                                                                           PORTIO2A.79    
void                                                                       GBC2C405.52    
*IF DEF,MPP                                                                GPB0C305.132   
*IF DEF,C_LOW                                                              GPB0C305.133   
open_single                                                                GPB0C305.134   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.135   
open_single_                                                               GPB0C305.136   
*ELSE                                                                      GPB0C305.137   
OPEN_SINGLE                                                                GPB0C305.138   
*ENDIF                                                                     GPB0C305.139   
*ELSE                                                                      GPB0C305.140   
*IF DEF,C_LOW                                                              TS140793.31    
file_open                                                                  GPB0C305.141   
*ELSEIF DEF,C_LOW_U                                                        TS140793.33    
file_open_                                                                 GPB0C305.142   
*ELSE                                                                      TS140793.35    
FILE_OPEN                                                                  GPB0C305.143   
*ENDIF                                                                     TS140793.37    
*ENDIF                                                                     GPB0C305.144   
*IF DEF,CRAY                                                               GBC0C402.4     
(unit,f_file_name, char_len,intent,environ_var_flag,err)                   GPB0C305.36    
_fcd f_file_name;    /* File name or environment variable    */            GPB0C305.37    
*ELSE                                                                      GPB0C305.38    
(unit,file_name, char_len,intent,environ_var_flag,err)                     GPB0C305.39    
char file_name[]; /* File name or environment variable    */               GPB0C305.40    
*ENDIF                                                                     GPB0C305.41    
integer *unit;       /* Fortran unit                         */            GPB0C305.42    
integer *char_len;   /* No of chars in file name             */            GPB0C305.43    
integer *intent    ; /* =0 read only,!=0 read and write      */            GPB0C305.44    
integer *environ_var_flag; /* =0 file name in environment var, */          GPB0C305.45    
                     /*!=0 explicit file name            */                GPB0C305.46    
integer *err;        /* =0 file opened,                  */                GPB0C305.47    
                     /*!=0 file not opened               */                GPB0C305.48    
{                                                                          RK151293.16    
   char *fname;                                                            PXPORTIO.4     
*IF DEF,CRAY                                                               GBC0C402.5     
   char *file_name;                                                        GBC6C404.150   
*ENDIF                                                                     GPB0C305.51    
   char *gname;                                                            RK151293.19    
*IF DEF,CRI_OPEN                                                           GBC6C404.151   
                                                                           GBC6C404.152   
#define C_FLAGS O_RDWR | O_CREAT | O_RAW | O_LDRAW | O_BIG                 GBC6C404.153   
                                                                           GBC6C404.154   
#define I_FLAGS IA_CONT | IA_RAVL                                          GBC6C404.155   
                                                                           GBC6C404.156   
#define J_FLAGS IA_RAVL                                                    GBC6C404.157   
                                                                           GBC6C404.158   
#define O_FLAGS O_RDWR | O_RAW | O_LDRAW | O_BIG                           GBC6C404.159   
                                                                           GBC6C404.160   
   struct ffsw local_stat;                                                 GBC6C404.161   
   int local_fd;                                                           GBC6C404.162   
   long i, k, l;                                                           GBC6C404.163   
   long jj, *j;                                                            GBC6C404.164   
*ELSE                                                                      GBC6C404.165   
   int i;                                                                  RK151293.20    
*ENDIF                                                                     GBC6C404.166   
                                                                           RK151293.21    
   int readonly = 0;                                                       RK151293.22    
                                                                           RK151293.23    
   enum   filestat { old, new };                                           RK151293.24    
   enum   filestat filestatus;                                             RK151293.25    
                                                                           RK151293.26    
                                                                           RK151293.27    
   fname = calloc(*char_len + 1, 1);                                       PXPORTIO.5     
   the_unit=unit;                                                          GBC6C404.167   
*IF DEF,CRI_FFIO                                                           GBC0C402.118   
   fd[*unit] = -1;                                                         GBC0C402.119   
*ELSE                                                                      GBC0C402.120   
   pf[*unit] = NULL;                                                       RK151293.28    
*ENDIF                                                                     GBC0C402.121   
*IF DEF,CRI_OPEN                                                           GBC6C404.168   
   j=&jj;                                                                  GBC6C404.169   
*ENDIF                                                                     GBC6C404.170   
/* convert file name to C format */                                        GBC6C404.171   
                                                                           RK151293.30    
*IF DEF,CRAY                                                               GBC0C402.6     
   file_name=__fcdtocp(f_file_name);                                       GBC6C404.172   
*ENDIF                                                                     GPB0C305.54    
   strncpy( fname, file_name, *char_len );                                 RK151293.31    
   fname[ *char_len ] = '\0';                                              RK151293.32    
   sscanf( fname, "%s", fname );                                           RK151293.33    
                                                                           RK151293.34    
                                                                           RK151293.35    
   if ( *environ_var_flag == 0 )  /* File name held in environ var */      RK151293.36    
   {  gname = getenv( fname );                                             GPB0C401.8     
      if ( gname == NULL ) {                                               GPB0C401.9     
        sprintf(message,                                                   GBC6C404.173   
         "OPEN:  WARNING: Environment variable %s not set",                GBC6C404.174   
         fname);                                                           GBC6C404.175   
        CALL_MESSAGE_PRINT(message);                                       GBC6C404.176   
        open_flag[*unit]=1;                                                GPB0C401.12    
        *err=1;                                                            GPB0C401.13    
        free (fname);                                                      PXPORTIO.6     
        return;                                                            GPB0C401.14    
      }                                                                    GPB0C401.15    
   }                                                                       GPB0C401.16    
   else                           /* get file name from argmt fname */     RK151293.38    
      gname = fname;                                                       RK151293.39    
                                                                           RK151293.40    
                                                                           RK151293.41    
   /* Check if file exists */                                              RK151293.42    
                                                                           RK151293.43    
   if ( access( gname, 0 ) == 0 )  {   /* file exists */                   RK151293.44    
                                                                           RK151293.45    
      sprintf(message,                                                     GBC6C404.177   
       "OPEN:  File %s to be Opened on Unit %d Exists",                    GBC6C404.178   
       gname, (int) *unit );                                               GBC6C404.179   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.180   
      filestatus = old;                                                    RK151293.47    
   }                                                                       RK151293.48    
   else  {   /* non-existent file */                                       RK151293.49    
                                                                           RK151293.50    
      sprintf(message,                                                     GBC6C404.181   
       "OPEN:  File %s to be Opened on Unit %d does not Exist",            GBC6C404.182   
       gname, (int) *unit);                                                GBC6C404.183   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.184   
      filestatus = new;                                                    RK151293.52    
   }                                                                       RK151293.53    
                                                                           RK151293.54    
                                                                           RK151293.55    
   if ( filestatus == old )  {                                             RK151293.56    
                                                                           RK151293.57    
      if ( *intent == readonly )  {                                        RK151293.58    
                                                                           RK151293.59    
*IF DEF,CRI_FFIO                                                           GBC0C402.122   
         if(( fd[*unit] = ffopens( gname, O_RDONLY | O_RAW | O_LDRAW,      GBC6C404.185   
          0, 0, &local_stat, "system")) == -1 )  {                         GBC6C404.186   
*ELSE                                                                      GBC0C402.124   
         if ( ( pf[*unit] = fopen( gname, "rb" ) ) == NULL )  {            RK151293.60    
*ENDIF                                                                     GBC0C402.125   
                                                                           RK151293.61    
            perror("OPEN:  File Open Failed");                             GBC6C404.187   
            sprintf(message,                                               GBC6C404.188   
              "OPEN:  Unable to Open File %s for Reading", gname );        GBC6C404.189   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.190   
         }                                                                 RK151293.64    
      }                                                                    RK151293.65    
      else  {   /*  *intent == read_and_write )  */                        RK151293.66    
                                                                           RK151293.67    
*IF DEF,CRI_FFIO                                                           GBC0C402.126   
         if(( fd[*unit] = ffopens( gname, O_RDWR | O_RAW | O_LDRAW,        GBC6C404.191   
          0, 0, &local_stat, "system")) == -1 )  {                         GBC6C404.192   
*ELSE                                                                      GBC0C402.128   
         if ( ( pf[*unit] = fopen( gname, "r+b" ) ) == NULL )  {           RK151293.68    
*ENDIF                                                                     GBC0C402.129   
                                                                           RK151293.69    
            perror("OPEN:  File Open Failed");                             GBC6C404.193   
            sprintf(message,                                               GBC6C404.194   
              "OPEN:  Unable to Open File %s for Read/Write", gname );     GBC6C404.195   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.196   
         }                                                                 RK151293.72    
      }                                                                    RK151293.73    
   }                                                                       RK151293.74    
                                                                           RK151293.75    
                                                                           RK151293.76    
/* New file - check for write */                                           GBC6C404.197   
   if ( filestatus == new )  {                                             RK151293.77    
                                                                           GBC6C404.198   
*IF DEF,CRI_FFIO                                                           GBC6C404.199   
/* Initialise the file control word */                                     GBC6C404.200   
      fd[*unit] = -1;                                                      GBC6C404.201   
*ELSE                                                                      GBC6C404.202   
/* Initialise the file control word to NULL */                             GBC6C404.203   
      pf[*unit] = NULL;                                                    GBC6C404.204   
*ENDIF                                                                     GBC6C404.205   
                                                                           RK151293.78    
      if ( *intent == readonly )  {                                        RK151293.79    
         sprintf(message, "OPEN:  **WARNING: FILE NOT FOUND" );            GBC6C404.206   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.207   
         sprintf(message,                                                  GBC6C404.208   
          "OPEN:  Ignored Request to Open File %s for Reading",            GBC6C404.209   
           gname );                                                        GBC6C404.210   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.211   
      }                                                                    RK151293.84    
      else  {        /*  *intent == read_and_write   */                    RK151293.85    
                                                                           GBC6C404.212   
*IF DEF,CRI_OPEN                                                           GBC6C404.213   
/* Check if we should create and size the file prior to the open. */       GBC6C404.214   
/* This is determined by whether the size is known.               */       GBC6C404.215   
        if(file_size[*unit] != 0) {                                        GBC6C404.216   
/* Initially create and open the file */                                   GBC6C404.217   
          if(( local_fd = open( gname, C_FLAGS, 00755)) == -1 ) {          GBC6C404.218   
                                                                           GBC6C404.219   
            perror("OPEN:  File Creation Failed");                         GBC6C404.220   
            sprintf(message,                                               GBC6C404.221   
             "OPEN:  Unable to Open File %s for Read/Write",               GBC6C404.222   
             gname );                                                      GBC6C404.223   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.224   
*IF DEF,CRI_FFIO                                                           GBC6C404.225   
            fd[*unit] = -1;                                                GBC6C404.226   
*ELSE                                                                      GBC6C404.227   
            pf[*unit] = NULL;                                              GBC6C404.228   
*ENDIF                                                                     GBC6C404.229   
          }                                                                GBC6C404.230   
/* Successfully opened the file */                                         GBC6C404.231   
          else  {                                                          GBC6C404.232   
            sprintf(message, "OPEN:  File %s Created on Unit %d",          GBC6C404.233   
                     gname, (int) *unit );                                 GBC6C404.234   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.235   
/* Now find out about the file system we are in */                         GBC6C404.236   
            if (fstatfs(local_fd, &stats, sizeof(struct statfs), 0)        GBC6C404.237   
             == -1) {                                                      GBC6C404.238   
              perror("OPEN:  statfs error");                               GBC6C404.239   
              abort();                                                     GBC6C404.240   
            }                                                              GBC6C404.241   
                                                                           GBC6C404.242   
/*                                                                         GBC6C404.243   
            if (sysfs(GETFSTYP, stats.f_fstyp, buf) == -1) {               GBC6C404.244   
              perror("OPEN:  sysfs (GETFSTYP) error");                     GBC6C404.245   
              abort();                                                     GBC6C404.246   
            }                                                              GBC6C404.247   
                                                                           GBC6C404.248   
            printf("File system type = %s\n", buf);                        GBC6C404.249   
            printf("Block size = %d\n", stats.f_bsize);                    GBC6C404.250   
            printf("Fragment size = %d\n", stats.f_frsize);                GBC6C404.251   
            printf("Total number of blocks on file system = %d\n",         GBC6C404.252   
             stats.f_blocks);                                              GBC6C404.253   
            printf("Total number of free blocks = %d\n",                   GBC6C404.254   
             stats.f_bfree);                                               GBC6C404.255   
            printf("Total number of file nodes (inodes) = %d\n",           GBC6C404.256   
             stats.f_files);                                               GBC6C404.257   
            printf("Total number of free file nodes = %d\n",               GBC6C404.258   
             stats.f_ffree);                                               GBC6C404.259   
            printf("Volume name = %s\n", stats.f_fname);                   GBC6C404.260   
            printf("Pack name = %s\n", stats.f_fpack);                     GBC6C404.261   
            printf("Primary partition bit map = %o\n",                     GBC6C404.262   
             stats.f_priparts);                                            GBC6C404.263   
            printf("Secondary partition bit map = %o\n",                   GBC6C404.264   
             stats.f_secparts);                                            GBC6C404.265   
            printf("Number of partitions = %d\n", stats.f_npart);          GBC6C404.266   
            printf("Big file threshold = %d bytes ", stats.f_bigsize);     GBC6C404.267   
            printf("or %d blocks\n", stats.f_bigsize/stats.f_bsize);       GBC6C404.268   
            printf("Big file allocation unit size = %d bytes ",            GBC6C404.269   
             stats.f_bigunit);                                             GBC6C404.270   
            printf("or %d blocks\n", stats.f_bigunit/stats.f_bsize);       GBC6C404.271   
            printf("Number of blocks in primary partitions = %d\n",        GBC6C404.272   
             stats.f_prinblks);                                            GBC6C404.273   
            printf("Number of free blocks in primary partitions = %d\n",   GBC6C404.274   
             stats.f_prinfree);                                            GBC6C404.275   
            printf("Primary partition allocation unit size = %d ",         GBC6C404.276   
             stats.f_priaunit);                                            GBC6C404.277   
            printf("bytes or %d blocks\n",                                 GBC6C404.278   
             stats.f_priaunit/stats.f_bsize);                              GBC6C404.279   
            printf("Number of blocks in secondary partitions = %d\n",      GBC6C404.280   
             stats.f_secnblks);                                            GBC6C404.281   
            printf(                                                        GBC6C404.282   
             "Number of free blocks in secondary partitions = %d\n",       GBC6C404.283   
             stats.f_secnfree);                                            GBC6C404.284   
            printf("Secondary partition allocation unit size = %d ",       GBC6C404.285   
             stats.f_secaunit);                                            GBC6C404.286   
            printf("bytes or %d blocks\n",                                 GBC6C404.287   
             stats.f_secaunit/stats.f_bsize); */                           GBC6C404.288   
                                                                           GBC6C404.289   
/* Round up the file size to a big file allocation unit.        */         GBC6C404.290   
/* This assumes the allocation unit is a correct multiple       */         GBC6C404.291   
/* of the allocation unit.                                      */         GBC6C404.292   
            i=stats.f_bigunit;                                             GBC6C404.293   
/* Check that the file allocation size is not zero - NFS files */          GBC2C405.53    
            if(i <= 0) i=1;                                                GBC2C405.54    
            file_size[*unit]=((file_size[*unit]+i-1)/i)*i;                 GBC6C404.294   
                                                                           GBC6C404.295   
/* Now extend the file to its full size */                                 GBC6C404.296   
            i=0;                                                           GBC6C404.297   
            *j=0;                                                          GBC6C404.298   
            l=I_FLAGS;                                                     GBC6C404.299   
            k=ialloc(local_fd, file_size[*unit], l, i, j);                 GBC6C404.300   
/* Did we managed to create a contiguous file of the right length? */      GBC2C405.55    
            if(k == file_size[*unit]) {                                    GBC6C404.301   
                                                                           GBC6C404.302   
              sprintf(message,                                             GBC6C404.303   
               "OPEN:  %d Contiguous Bytes Allocated for File %s",         GBC6C404.304   
               (int) file_size[*unit], gname);                             GBC6C404.305   
              CALL_MESSAGE_PRINT(message);                                 GBC6C404.306   
/* Now close the file, and reopen it as we want */                         GBC6C404.307   
              k=close(local_fd);                                           GBC6C404.308   
              if(k != 0) {                                                 GBC6C404.309   
                perror("OPEN:  Close during File Creation Failed");        GBC6C404.310   
                sprintf(message,                                           GBC6C404.311   
                 "OPEN:  Unable to Close Newly Created File %s",           GBC6C404.312   
                 gname);                                                   GBC6C404.313   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.314   
                abort();                                                   GBC6C404.315   
              }                                                            GBC6C404.316   
/* Now open the file again */                                              GBC6C404.317   
*IF DEF,CRI_FFIO                                                           GBC6C404.318   
              if((fd[*unit] = ffopens(gname, O_FLAGS,                      GBC6C404.319   
               0, 0, &local_stat, "system")) == -1)  {                     GBC6C404.320   
*ELSE                                                                      GBC6C404.321   
              if ( ( pf[*unit] = fopen( gname, "r+b" ) ) == NULL )  {      GBC6C404.322   
*ENDIF                                                                     GBC6C404.323   
                perror("OPEN:  Re-open Newly Created File Failed");        GBC6C404.324   
                sprintf(message,                                           GBC6C404.325   
                 "OPEN:  Unable to Open Newly Created File %s",            GBC6C404.326   
                 gname);                                                   GBC6C404.327   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.328   
                abort();                                                   GBC6C404.329   
              }                                                            GBC6C404.330   
            }                                                              GBC6C404.331   
/*                                                                         GBC2C405.56    
                                                                           GBC2C405.57    
  End of the Block for Contiguous Allocation */                            GBC2C405.58    
                                                                           GBC2C405.59    
                                                                           GBC2C405.60    
            else {                                                         GBC6C404.332   
/* Open for contiguous space failed -                                      GBC6C404.333   
   try again for non-contiguous space */                                   GBC6C404.334   
              i=0;                                                         GBC6C404.335   
              *j=0;                                                        GBC6C404.336   
              l=J_FLAGS;                                                   GBC6C404.337   
              k=ialloc(local_fd, file_size[*unit], l, i, j);               GBC6C404.338   
/* Check if we have allocated space for the file */                        GBC2C405.61    
              if(k == file_size[*unit]) {                                  GBC6C404.339   
                                                                           GBC6C404.340   
                sprintf(message,                                           GBC6C404.341   
                 "OPEN:  %d Bytes Allocated for File %s",                  GBC6C404.342   
                 (int) file_size[*unit], gname);                           GBC6C404.343   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.344   
/* Now close the file, and reopen it as we want */                         GBC6C404.345   
                k=close(local_fd);                                         GBC6C404.346   
                if(k != 0) {                                               GBC6C404.347   
                  perror("OPEN:  Close during File Creation Failed");      GBC6C404.348   
                  sprintf(message,                                         GBC6C404.349   
                   "OPEN:  Unable to Close Newly Created File %s",         GBC6C404.350   
                   gname);                                                 GBC6C404.351   
                  CALL_MESSAGE_PRINT(message);                             GBC6C404.352   
                  abort();                                                 GBC6C404.353   
                }                                                          GBC6C404.354   
/* Now open the file again, using fopen now */                             GBC6C404.355   
*IF DEF,CRI_FFIO                                                           GBC6C404.356   
                if((fd[*unit] = ffopens(gname, O_FLAGS,                    GBC6C404.357   
                 0, 0, &local_stat, "system")) == -1)  {                   GBC6C404.358   
*ELSE                                                                      GBC6C404.359   
                if ( ( pf[*unit] = fopen( gname, "r+b" ) ) == NULL )  {    GBC6C404.360   
*ENDIF                                                                     GBC6C404.361   
                  perror("OPEN:  Re-open Newly Created File Failed");      GBC6C404.362   
                  sprintf(message,                                         GBC6C404.363   
                    "OPEN:  Unable to Open Newly Created File %s",         GBC6C404.364   
                   gname);                                                 GBC6C404.365   
                  CALL_MESSAGE_PRINT(message);                             GBC6C404.366   
                  abort();                                                 GBC6C404.367   
                }                                                          GBC6C404.368   
              }                                                            GBC6C404.369   
/*                                                                         GBC2C405.62    
                                                                           GBC2C405.63    
  End of the attempts to allocate space - if there seems to                GBC2C405.64    
  be enough space available, just create the file with no allocation. */   GBC2C405.65    
                                                                           GBC2C405.66    
                                                                           GBC2C405.67    
              else {                                                       GBC6C404.370   
/* Unable to allocate space non-contiguously either - check the space      GBC6C404.371   
   available by finding out about the file system we are in */             GBC6C404.372   
                                                                           GBC6C404.373   
                if (fstatfs(local_fd, &stats, sizeof(struct statfs), 0)    GBC6C404.374   
                 == -1) {                                                  GBC6C404.375   
                  perror("OPEN:  statfs error");                           GBC6C404.376   
                  abort();                                                 GBC6C404.377   
                }                                                          GBC6C404.378   
                                                                           GBC6C404.379   
                if (sysfs(GETFSTYP, stats.f_fstyp, buf) == -1) {           GBC6C404.380   
                  perror("OPEN:  sysfs (GETFSTYP) error");                 GBC6C404.381   
                  abort();                                                 GBC6C404.382   
                }                                                          GBC6C404.383   
                                                                           GBC6C404.384   
                l=stats.f_bsize*stats.f_bfree;                             GBC6C404.385   
/* if there is sufficient free space, use the file                         GBC2C405.68    
   with no space allocated */                                              GBC6C404.387   
                if(l > file_size[*unit]) {                                 GBC6C404.388   
/* Now close the file, and reopen it as we want */                         GBC6C404.389   
                  k=close(local_fd);                                       GBC6C404.390   
                  if(k != 0) {                                             GBC6C404.391   
                    perror("OPEN:  Close during File Creation Failed");    GBC6C404.392   
                    sprintf(message,                                       GBC6C404.393   
                     "OPEN:  Unable to Close Newly Created File %s",       GBC6C404.394   
                     gname);                                               GBC6C404.395   
                    CALL_MESSAGE_PRINT(message);                           GBC6C404.396   
                    abort();                                               GBC6C404.397   
                  }                                                        GBC6C404.398   
/* Now open the file again, using fopen now */                             GBC6C404.399   
*IF DEF,CRI_FFIO                                                           GBC6C404.400   
                  if((fd[*unit] = ffopens(gname, O_FLAGS,                  GBC6C404.401   
                   0, 0, &local_stat, "system")) == -1)  {                 GBC6C404.402   
*ELSE                                                                      GBC6C404.403   
                  if (( pf[*unit] = fopen( gname, "r+b" ) ) == NULL) {     GBC6C404.404   
*ENDIF                                                                     GBC6C404.405   
                    perror("OPEN:  Re-open Newly Created File Failed");    GBC6C404.406   
                    sprintf(message,                                       GBC6C404.407   
                      "OPEN:  Unable to Open Newly Created File %s",       GBC6C404.408   
                     gname);                                               GBC6C404.409   
                    CALL_MESSAGE_PRINT(message);                           GBC6C404.410   
                    abort();                                               GBC6C404.411   
                  }                                                        GBC6C404.412   
                }                                                          GBC6C404.413   
/*                                                                         GBC2C405.69    
                                                                           GBC2C405.70    
  End of the attempts to pre-allocate space - there seems to be            GBC2C405.71    
  insufficient space available,  so we dump the stats and abort. */        GBC2C405.72    
                                                                           GBC2C405.73    
                                                                           GBC2C405.74    
                else {                                                     GBC6C404.414   
/* Not enough space - pack up */                                           GBC6C404.415   
                  fprintf(stderr,                                          GBC6C404.416   
                   "\nAllocate for File %s for %d Bytes ",                 GBC6C404.417   
                   gname, file_size[*unit]);                               GBC6C404.418   
                  fprintf(stderr, "got Response %d\n\n", k);               GBC6C404.419   
                                                                           GBC6C404.420   
                  fprintf(stderr, "File system type = %s\n", buf);         GBC6C404.421   
                  fprintf(stderr, "Block size = %d\n", stats.f_bsize);     GBC6C404.422   
                  fprintf(stderr, "Fragment size = %d\n",                  GBC6C404.423   
                   stats.f_frsize);                                        GBC6C404.424   
                  fprintf(stderr,                                          GBC6C404.425   
                   "Total number of blocks on file system = %d\n",         GBC6C404.426   
                   stats.f_blocks);                                        GBC6C404.427   
                  fprintf(stderr,                                          GBC6C404.428   
                   "Total number of free blocks = %d\n",                   GBC6C404.429   
                   stats.f_bfree);                                         GBC6C404.430   
                  fprintf(stderr,                                          GBC6C404.431   
                   "Total number of file nodes (inodes) = %d\n",           GBC6C404.432   
                   stats.f_files);                                         GBC6C404.433   
                  fprintf(stderr,                                          GBC6C404.434   
                   "Total number of free file nodes = %d\n",               GBC6C404.435   
                   stats.f_ffree);                                         GBC6C404.436   
                  fprintf(stderr, "Volume name = %s\n", stats.f_fname);    GBC6C404.437   
                  fprintf(stderr, "Pack name = %s\n", stats.f_fpack);      GBC6C404.438   
                  fprintf(stderr, "Primary partition bit map = %o\n",      GBC6C404.439   
                   stats.f_priparts);                                      GBC6C404.440   
                  fprintf(stderr, "Secondary partition bit map = %o\n",    GBC6C404.441   
                   stats.f_secparts);                                      GBC6C404.442   
                  fprintf(stderr,                                          GBC6C404.443   
                   "Number of partitions = %d\n", stats.f_npart);          GBC6C404.444   
                  fprintf(stderr,                                          GBC6C404.445   
                   "Big file threshold = %d bytes ", stats.f_bigsize);     GBC6C404.446   
                  fprintf(stderr,                                          GBC6C404.447   
                   "or %d blocks\n", stats.f_bigsize/stats.f_bsize);       GBC6C404.448   
                  fprintf(stderr,                                          GBC6C404.449   
                   "Big file allocation unit size = %d bytes ",            GBC6C404.450   
                   stats.f_bigunit);                                       GBC6C404.451   
                  fprintf(stderr,                                          GBC6C404.452   
                   "or %d blocks\n", stats.f_bigunit/stats.f_bsize);       GBC6C404.453   
                  fprintf(stderr,                                          GBC6C404.454   
                   "Number of blocks in primary partitions = %d\n",        GBC6C404.455   
                   stats.f_prinblks);                                      GBC6C404.456   
                  fprintf(stderr,                                          GBC6C404.457   
                   "Number of free blocks in primary partitions = %d\n",   GBC6C404.458   
                   stats.f_prinfree);                                      GBC6C404.459   
                  fprintf(stderr,                                          GBC6C404.460   
                   "Primary partition allocation unit size = %d ",         GBC6C404.461   
                   stats.f_priaunit);                                      GBC6C404.462   
                  fprintf(stderr, "bytes or %d blocks\n",                  GBC6C404.463   
                   stats.f_priaunit/stats.f_bsize);                        GBC6C404.464   
                  fprintf(stderr,                                          GBC6C404.465   
                   "Number of blocks in secondary partitions = %d\n",      GBC6C404.466   
                   stats.f_secnblks);                                      GBC6C404.467   
                  fprintf(stderr,                                          GBC6C404.468   
                   "No. of free blocks in secondary partitions = %d\n",    GBC6C404.469   
                   stats.f_secnfree);                                      GBC6C404.470   
                  fprintf(stderr,                                          GBC6C404.471   
                   "Secondary partition allocation unit size = %d ",       GBC6C404.472   
                   stats.f_secaunit);                                      GBC6C404.473   
                  fprintf(stderr, "bytes or %d blocks\n",                  GBC6C404.474   
                   stats.f_secaunit/stats.f_bsize);                        GBC6C404.475   
                                                                           GBC6C404.476   
                  sprintf(message,                                         GBC6C404.477   
                   "OPEN:  Unable to allocate Space for File %s",          GBC6C404.478   
                   gname);                                                 GBC6C404.479   
                  CALL_MESSAGE_PRINT(message);                             GBC6C404.480   
                  abort();                                                 GBC6C404.481   
                }                                                          GBC6C404.482   
              }                                                            GBC6C404.483   
            }                                                              GBC6C404.484   
          }                                                                GBC6C404.485   
        }                                                                  GBC6C404.486   
/*                                                                         GBC2C405.75    
                                                                           GBC2C405.76    
  No file size given - create a zero length file */                        GBC2C405.77    
                                                                           GBC2C405.78    
        else {                                                             GBC6C404.487   
*ENDIF                                                                     GBC6C404.488   
/* File size not given - just open the file normally */                    GBC6C404.489   
*IF DEF,CRI_FFIO                                                           GBC6C404.490   
          if((fd[*unit] = ffopens(gname, C_FLAGS, 00755,                   GBC6C404.491   
           0, &local_stat, "system")) == -1)  {                            GBC6C404.492   
*ELSE                                                                      GBC6C404.493   
          if ( ( pf[*unit] = fopen( gname, "w+b" ) ) == NULL )  {          GBC6C404.494   
*ENDIF                                                                     GBC6C404.495   
                                                                           GBC6C404.496   
            perror("OPEN:  File Creation Failed");                         GBC6C404.497   
            sprintf(message,                                               GBC6C404.498   
             "OPEN:  Unable to Open File %s for Read/Write", gname );      GBC6C404.499   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.500   
          }                                                                GBC6C404.501   
          else  {                                                          GBC6C404.502   
            sprintf(message, "OPEN:  File %s Created on Unit %d",          GBC6C404.503   
                     gname, (int) *unit );                                 GBC6C404.504   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.505   
          }                                                                GBC6C404.506   
*IF DEF,CRI_OPEN                                                           GBC6C404.507   
        }                                                                  GBC6C404.508   
*ENDIF                                                                     GBC6C404.509   
      }                                                                    GBC6C404.510   
   }                                                                       GBC6C404.511   
                                                                           RK151293.98    
                                                                           RK151293.99    
                                                                           RK151293.100   
   /* Set error code and open flag used by buffin and buffout */           RK151293.101   
                                                                           RK151293.102   
*IF DEF,CRI_FFIO                                                           GBC0C402.135   
   if( fd[*unit] == -1 )  {                                                GBC0C402.136   
*ELSE                                                                      GBC0C402.137   
   if( pf[*unit] == NULL )  {                                              RK151293.103   
*ENDIF                                                                     GBC0C402.138   
                                                                           RK151293.104   
      *err = 1;                                                            RK151293.105   
      open_flag[*unit]=1;                                                  RK151293.106   
   }                                                                       RK151293.107   
   else  {                                                                 RK151293.108   
*IF DEF,CRI_FFIO                                                           GBC0C402.139   
         *err = 0;                                                         GBC0C402.140   
         open_flag[*unit]=0;                                               GBC0C402.141   
*ELSE                                                                      GBC0C402.142   
      if ( setvbuf( pf[*unit], NULL, _IOFBF, BUFSIZ ) != 0 )  {            RK151293.109   
         perror("\n**Warning: setvbuf failed");                            GBC6C404.512   
         *err=1;                                                           RK151293.111   
         open_flag[*unit]=1;                                               RK151293.112   
       }                                                                   RK151293.113   
       else                                                                RK151293.114   
       {                                                                   RK151293.115   
         *err = 0;                                                         RK151293.116   
         open_flag[*unit]=0;                                               RK151293.117   
                                                                           RK151293.118   
/*    set buffer to default size to force buffer alloc on heap */          RK151293.119   
  /*  setvbuf(pf[*unit],NULL,_IOFBF,BUFSIZ);  See above */                 RK151293.120   
        }                                                                  RK151293.121   
*ENDIF                                                                     GBC0C402.143   
   }                                                                       RK151293.122   
   io_position[*unit]=0;                                                   GBC6C404.513   
                                                                           GBC2C405.115   
*IF DEF,C_LOW                                                              GBC2C405.116   
   clear_unit_bcast_flag(unit);                                            GBC2C405.117   
*ELSEIF DEF,C_LOW_U                                                        GBC2C405.118   
   clear_unit_bcast_flag_(unit);                                           GBC2C405.119   
*ELSE                                                                      GBC2C405.120   
   CLEAR_UNIT_BCAST_FLAG(unit);                                            GBC2C405.121   
*ENDIF                                                                     GBC2C405.122   
                                                                           GBC2C405.123   
free (fname);                                                              PXPORTIO.7     
}                                                                          RK151293.123   
                                                                           RK151293.124   
                                                                           PORTIO2A.188   
                                                                           PORTIO2A.189   
void                                                                       GBC2C405.79    
*IF DEF,MPP                                                                GPB0C305.145   
*IF DEF,C_LOW                                                              GPB0C305.146   
close_single                                                               GPB0C305.147   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.148   
close_single_                                                              GPB0C305.149   
*ELSE                                                                      GPB0C305.150   
CLOSE_SINGLE                                                               GPB0C305.151   
*ENDIF                                                                     GPB0C305.152   
*ELSE                                                                      GPB0C305.153   
*IF DEF,C_LOW                                                              TS140793.39    
file_close                                                                 GPB0C305.154   
*ELSEIF DEF,C_LOW_U                                                        TS140793.41    
file_close_                                                                GPB0C305.155   
*ELSE                                                                      TS140793.43    
FILE_CLOSE                                                                 GPB0C305.156   
*ENDIF                                                                     TS140793.45    
*ENDIF                                                                     GPB0C305.157   
*IF DEF,CRAY                                                               GBC0C402.7     
(unit,f_file_name,char_len,environ_var_flag,delete,err)                    GTD0C400.6     
_fcd f_file_name;    /* File name or environment variable    */            GPB0C305.57    
*ELSE                                                                      GPB0C305.58    
(unit,file_name,char_len,environ_var_flag,delete,err)                      GTD0C400.7     
char file_name[];    /* File name or environment variable    */            GPB0C305.60    
*ENDIF                                                                     GPB0C305.61    
integer *unit;       /* Fortran unit                         */            GPB0C305.62    
integer *char_len;   /* No of chars in file name             */            GPB0C305.63    
integer *delete;     /* =0 do not delete file,!=0 delete file*/            GPB0C305.64    
integer *environ_var_flag; /* =0 file name in environment var, */          GPB0C305.65    
                           /*!=0 explicit file name            */          GPB0C305.66    
integer *err; /* ERROR CHECKING err = 0 no errors, err = 1 Errors */       GBC2C405.80    
{                                                                          PORTIO2A.197   
char *fname;                                                               PXPORTIO.8     
char *gname;                                                               PORTIO2A.199   
*IF DEF,CRAY                                                               GBC0C402.8     
char *file_name;                                                           GPB0C305.68    
*ENDIF                                                                     GPB0C305.69    
int i;                                                                     PORTIO2A.200   
int k;                                                                     PORTIO2A.201   
                                                                           GRR1C304.9     
the_unit=unit;                                                             GBC6C404.514   
fname = calloc(*char_len + 1, 1);                                          PXPORTIO.9     
/* first check to see if unit has been closed already (or not opened)*/    GRR1C304.10    
if(open_flag[*unit]== 0){    /* unit currently open  */                    GRR1C304.11    
                                                                           GRR1C304.12    
/* close file */                                                           PORTIO2A.202   
*IF DEF,CRI_FFIO                                                           GBC0C402.144   
      k=ffclose(fd[*unit]);                                                GBC0C402.145   
*ELSE                                                                      GBC0C402.146   
      k=fclose(pf[*unit]);                                                 PORTIO2A.203   
*ENDIF                                                                     GBC0C402.147   
                                                                           PORTIO2A.204   
/* convert file name to C format */                                        PORTIO2A.205   
*IF DEF,CRAY                                                               GBC0C402.9     
        file_name=__fcdtocp(f_file_name);                                  GBC6C404.515   
*ENDIF                                                                     GPB0C305.72    
        strncpy(fname,file_name,*char_len);                                PORTIO2A.206   
        fname[*char_len] = '\0';                                           PORTIO2A.207   
        for (i=0; i<*char_len; i++){                                       PORTIO2A.208   
                                                                           PORTIO2A.209   
            if (fname[i] == ' '){                                          PORTIO2A.210   
               fname[i] = '\0';                                            PORTIO2A.211   
               break;                                                      PORTIO2A.212   
            }                                                              PORTIO2A.213   
         }                                                                 PORTIO2A.214   
                                                                           PORTIO2A.215   
        if(*environ_var_flag == 0)                                         PORTIO2A.216   
          { gname = getenv( fname );                                       GPB0C401.17    
            if ( gname == NULL ) {                                         GPB0C401.18    
*IF DEF,DIAG92                                                             GBC6C404.516   
              sprintf(message,                                             GBC6C404.517   
               "CLOSE: WARNING: Environment variable %s not set",          GBC6C404.518   
               fname);                                                     GBC6C404.519   
              CALL_MESSAGE_PRINT(message);                                 GBC6C404.520   
*ENDIF                                                                     GBC6C404.521   
            open_flag[*unit]=1;                                            GPB0C401.21    
            *err=1;                                                        GPB0C401.22    
            free( fname );                                                 PXPORTIO.10    
            return;                                                        GPB0C401.23    
            }                                                              GPB0C401.24    
          }                                                                GPB0C401.25    
        else                                                               PORTIO2A.218   
          gname=fname;                                                     PORTIO2A.219   
                                                                           PORTIO2A.220   
*IF DEF,CRI_FFIO                                                           GBC0C402.148   
       if(k >= 0){                                                         GBC0C402.149   
*ELSE                                                                      GBC0C402.150   
      if(k==0){                                                            PORTIO2A.221   
*ENDIF                                                                     GBC0C402.151   
                                                                           PORTIO2A.222   
/* delete file */                                                          PORTIO2A.223   
        if(*delete != 0){                                                  PORTIO2A.224   
          k=remove(gname);                                                 PORTIO2A.225   
          if( k != 0){                                                     PORTIO2A.227   
*IF DEF,DIAG92                                                             GBC6C404.522   
            sprintf(message,                                               GBC6C404.523   
             "CLOSE: Cannot Delete File %s",gname);                        GBC6C404.524   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.525   
*ENDIF                                                                     GBC6C404.526   
            *err = 1;                                                      GTD0C400.9     
            abort();                                                       PORTIO2A.229   
          }                                                                PORTIO2A.230   
          else{  /*normal end to delete so:*/                              GTD0C400.10    
            open_flag[*unit]=1;     /* set unit flag to closed */          GRR1C304.14    
            *err = 0;                                                      GTD0C400.11    
*IF DEF,DIAG92                                                             GBC6C404.527   
            sprintf(message,                                               GBC6C404.528   
             "CLOSE: File %s Deleted", gname);                             GBC6C404.529   
            CALL_MESSAGE_PRINT(message);                                   GBC6C404.530   
*ENDIF                                                                     GBC6C404.531   
          }                                                                GTD0C400.12    
                                                                           PORTIO2A.231   
        }                                                                  PORTIO2A.232   
        else{                                                              PORTIO2A.233   
/* file closed */                                                          PORTIO2A.234   
           open_flag[*unit]=1;     /* set unit flag to closed */           GRR1C304.15    
*IF DEF,DIAG92                                                             GBC6C404.532   
          sprintf(message,                                                 GBC6C404.533   
           "CLOSE: File %s Closed on Unit %d",                             GBC6C404.534   
           gname, (int) *unit);                                            GBC6C404.535   
          CALL_MESSAGE_PRINT(message);                                     GBC6C404.536   
*ENDIF                                                                     GBC6C404.537   
        }                                                                  PORTIO2A.236   
      }                                                                    PORTIO2A.237   
/* file not closed */                                                      PORTIO2A.238   
*IF DEF,DIAG92                                                             GBC6C404.538   
    else {                                                                 GBC6C404.539   
          sprintf(message,                                                 GBC6C404.540   
           "CLOSE: Cannot Close File %s on Unit %d",                       GBC6C404.541   
           gname, (int) *unit);                                            GBC6C404.542   
          CALL_MESSAGE_PRINT(message);                                     GBC6C404.543   
    }                                                                      GBC6C404.544   
*ENDIF                                                                     GBC6C404.545   
}   /* end of test for unit already closed */                              GRR1C304.16    
                                                                           GRR1C304.17    
else {                                                                     GBC6C404.546   
/* unit either closed already or not open yet */                           GRR1C304.19    
  sprintf(message,                                                         GBC6C404.547   
   "CLOSE: WARNING: Unit %d Not Opened", (int) *unit);                     GBC6C404.548   
  CALL_MESSAGE_PRINT(message);                                             GBC6C404.549   
}                                                                          GBC6C404.550   
                                                                           GRR1C304.21    
free( fname );                                                             PXPORTIO.11    
}                                                                          PORTIO2A.241   
                                                                           PORTIO2A.242   
                                                                           PORTIO2A.243   
void                                                                       GBC2C405.81    
*IF DEF,C_LOW                                                              TS140793.47    
date_time                                                                  TS140793.48    
*ELSEIF DEF,C_LOW_U                                                        TS140793.49    
date_time_                                                                 TS140793.50    
*ELSE                                                                      TS140793.51    
DATE_TIME                                                                  TS140793.52    
*ENDIF                                                                     TS140793.53    
(year,month,day,hour,minute,second)                                        TS140793.54    
integer *year;       /* year                  */                           GPB0C305.73    
integer *month;      /* month   Current date  */                           GPB0C305.74    
integer *day;        /* day      and time     */                           GPB0C305.75    
integer *hour;       /* hour                  */                           GPB0C305.76    
integer *minute;     /* minute                */                           GPB0C305.77    
integer *second;     /* second                */                           GPB0C305.78    
                                                                           AD100293.22    
{                                                                          AD100293.23    
char s[5];                                                                 AD100293.24    
time_t t,*r,a;                                                             AD061193.1     
    r=&a;                                                                  AD100293.26    
    t=time(r);                                                             AD100293.27    
    strftime(s,5,"%Y",localtime(r));                                       AD100293.28    
    *year=atoi(s);                                                         AD100293.29    
    strftime(s,5,"%m",localtime(r));                                       AD100293.30    
    *month=atoi(s);                                                        AD100293.31    
    strftime(s,5,"%d",localtime(r));                                       AD100293.32    
    *day=atoi(s);                                                          AD100293.33    
    strftime(s,5,"%H",localtime(r));                                       AD100293.34    
    *hour=atoi(s);                                                         AD100293.35    
    strftime(s,5,"%M",localtime(r));                                       AD100293.36    
    *minute=atoi(s);                                                       AD100293.37    
    strftime(s,5,"%S",localtime(r));                                       AD100293.38    
    *second=atoi(s);                                                       AD100293.39    
}                                                                          AD100293.40    
void                                                                       GBC2C405.82    
*IF DEF,C_LOW                                                              TS140793.55    
shell                                                                      TS140793.56    
*ELSEIF DEF,C_LOW_U                                                        TS140793.57    
shell_                                                                     TS140793.58    
*ELSE                                                                      TS140793.59    
SHELL                                                                      TS140793.60    
*ENDIF                                                                     TS140793.61    
*IF DEF,CRAY                                                               GBC0C402.10    
(f_command,command_len)                                                    GPB0C305.81    
_fcd f_command  ;    /* Command to be executed               */            GPB0C305.82    
*ELSE                                                                      GPB0C305.83    
(command,command_len)                                                      GPB0C305.84    
char command  []; /* Command to be executed               */               GPB0C305.85    
*ENDIF                                                                     GPB0C305.86    
integer *command_len; /* No of chars in command               */           GPB0C305.87    
{                                                                          PORTIO2A.247   
char *fname;                                                               PXPORTIO.12    
int i;                                                                     PORTIO2A.249   
*IF DEF,CRAY                                                               GBC0C402.11    
char *command;                                                             GPB0C305.89    
*ENDIF                                                                     GPB0C305.90    
                                                                           PORTIO2A.250   
/* convert file name to C format */                                        PORTIO2A.251   
                                                                           PORTIO2A.252   
fname = calloc( *command_len + 1, 1);                                      PXPORTIO.13    
*IF DEF,CRAY                                                               GBC0C402.12    
command=__fcdtocp(f_command);                                              GPB0C305.92    
*ENDIF                                                                     GPB0C305.93    
strncpy(fname,command,*command_len);                                       PORTIO2A.253   
fname[*command_len]='\0';                                                  PORTIO2A.254   
                                                                           PORTIO2A.255   
/* execute command */                                                      PORTIO2A.256   
        i=system(fname);                                                   PORTIO2A.257   
                                                                           PORTIO2A.258   
free( fname );                                                             PXPORTIO.14    
}                                                                          PORTIO2A.259   
                                                                           PORTIO2A.260   
void                                                                       GBC2C405.83    
*IF DEF,C_LOW                                                              TS140793.63    
buffo32                                                                    TS140793.64    
*ELSEIF DEF,C_LOW_U                                                        TS140793.65    
buffo32_                                                                   TS140793.66    
*ELSE                                                                      TS140793.67    
BUFFO32                                                                    TS140793.68    
*ENDIF                                                                     TS140793.69    
(unit, array, maxlen, length, status)                                      TS140793.70    
integer *unit;     /* Fortran unit                            */           GPB0C305.94    
*IF DEF,CRI_FFIO                                                           GBC0C402.152   
char array[];      /* Array from which data is written        */           GBC0C402.153   
*ELSE                                                                      GBC0C402.154   
real array[];      /* Array from which data is written        */           GPB0C305.95    
*ENDIF                                                                     GBC0C402.155   
integer *maxlen;   /* Number of real numbers to be written    */           GPB0C305.96    
integer *length;   /* Number of real numbers actually written */           GPB0C305.97    
real *status;      /* Return code                             */           GPB0C305.98    
{                                                                          PORTIO2A.267   
int k;                                                                     PORTIO2A.268   
                                                                           PORTIO2A.269   
                                                                           GPB0C405.81    
    if (open_flag[*unit]==0){                                              GPB0C405.82    
*IF DEF,CRI_FFIO                                                           GBC0C402.156   
    k = ffwrite(fd[*unit], array, 4*(*maxlen));                            GBC0C402.157   
    *length = k/4;                                                         GBC0C402.158   
                                                                           GBC0C402.159   
        *status=-1.0;                                                      GBC0C402.160   
    if(k == -1)                                                            GBC0C402.161   
    {                                                                      GBC0C402.162   
      k=errno;                                                             GBC0C402.163   
      printf("C I/O Error: failed in BUFFO32\n");                          GBC0C402.164   
      printf("Return code = %d\n",k);                                      GBC0C402.165   
      if(k == FFEOF || k == FFEOD)                                         GBC0C402.166   
      {                                                                    GBC0C402.167   
        *status=0.0;                                                       GBC0C402.168   
      }                                                                    GBC0C402.169   
      if(k == FFEOR)                                                       GBC0C402.170   
      {                                                                    GBC0C402.171   
        *status=1.0;                                                       GBC0C402.172   
      }                                                                    GBC0C402.173   
      if(k == FFERR)                                                       GBC0C402.174   
      {                                                                    GBC0C402.175   
        *status=2.0;                                                       GBC0C402.176   
      }                                                                    GBC0C402.177   
*ELSE                                                                      GBC0C402.179   
    *length = fwrite(array,4,*maxlen,pf [*unit]);                          PORTIO2A.270   
                                                                           PORTIO2A.271   
        *status=-1.0;                                                      PORTIO2A.272   
        k=feof(pf[*unit]);                                                 PORTIO2A.273   
    if(k != 0)                                                             TS210793.26    
    {                                                                      TS210793.27    
      printf("C I/O Error: failed in BUFFO32\n");                          TS210793.28    
      printf("Return code = %d\n",k);                                      TS210793.29    
      *status=0.0;                                                         TS210793.30    
    }                                                                      TS210793.31    
        k=ferror(pf[*unit]);                                               PORTIO2A.275   
    if(k != 0)                                                             TS210793.32    
    {                                                                      TS210793.33    
      printf("C I/O Error: failed in BUFFO32\n");                          TS210793.34    
      printf("Return code = %d\n",k);                                      TS210793.35    
      *status=1.0;                                                         TS210793.36    
*ENDIF                                                                     GBC0C402.180   
      }                                                                    GPB0C405.83    
    }                                                                      GPB0C405.84    
      else                                                                 GPB0C405.85    
        *status=3.0;                                                       GPB0C405.86    
                                                                           PORTIO2A.277   
}                                                                          PORTIO2A.278   
                                                                           GPB0C405.11    
void                                                                       GPB0C405.12    
*IF DEF,C_LOW                                                              GPB0C405.13    
buffin32                                                                   GPB0C405.14    
*ELSEIF DEF,C_LOW_U                                                        GPB0C405.15    
buffin32_                                                                  GPB0C405.16    
*ELSE                                                                      GPB0C405.17    
BUFFIN32                                                                   GPB0C405.18    
*ENDIF                                                                     GPB0C405.19    
(unit, array, maxlen, length, status)                                      GPB0C405.20    
integer *unit;     /* Fortran unit                         */              GPB0C405.21    
*IF DEF,CRI_FFIO                                                           GPB0C405.22    
char array[];      /* Array from which data is read        */              GPB0C405.23    
*ELSE                                                                      GPB0C405.24    
real array[];      /* Array from which data is read        */              GPB0C405.25    
*ENDIF                                                                     GPB0C405.26    
integer *maxlen;   /* Number of real numbers to be read    */              GPB0C405.27    
integer *length;   /* Number of real numbers actually read */              GPB0C405.28    
real *status;      /* Return code                          */              GPB0C405.29    
{                                                                          GPB0C405.30    
int k;                                                                     GPB0C405.31    
                                                                           GPB0C405.32    
    if (open_flag[*unit]==0){                                              GPB0C405.33    
                                                                           GPB0C405.34    
*IF DEF,CRI_FFIO                                                           GPB0C405.35    
      k = ffread(fd[*unit], array, 4*(*maxlen));                           GPB0C405.36    
      *length = k/4;                                                       GPB0C405.37    
                                                                           GPB0C405.38    
      *status=-1.0;                                                        GPB0C405.39    
      if(k == -1)                                                          GPB0C405.40    
      {                                                                    GPB0C405.41    
        k=errno;                                                           GPB0C405.42    
                                                                           GPB0C405.43    
                                                                           GPB0C405.44    
        if(k == FFEOF || k == FFEOD)                                       GPB0C405.45    
        {                                                                  GPB0C405.46    
          *status=0.0;                                                     GPB0C405.47    
        }                                                                  GPB0C405.48    
        if(k == FFEOR)                                                     GPB0C405.49    
        {                                                                  GPB0C405.50    
          *status=1.0;                                                     GPB0C405.51    
        }                                                                  GPB0C405.52    
        if(k == FFERR)                                                     GPB0C405.53    
        {                                                                  GPB0C405.54    
          *status=2.0;                                                     GPB0C405.55    
        }                                                                  GPB0C405.56    
*ELSE                                                                      GPB0C405.57    
      *length = fread(array,4,*maxlen,pf [*unit]);                         GPB0C405.58    
                                                                           GPB0C405.59    
      *status=-1.0;                                                        GPB0C405.60    
      k=feof(pf[*unit]);                                                   GPB0C405.61    
      if(k != 0)                                                           GPB0C405.62    
      {                                                                    GPB0C405.63    
        printf("C I/O Error: failed in BUFFIN32\n");                       GPB0C405.64    
        printf("Return code = %d\n",k);                                    GPB0C405.65    
        *status=0.0;                                                       GPB0C405.66    
      }                                                                    GPB0C405.67    
      k=ferror(pf[*unit]);                                                 GPB0C405.68    
      if(k != 0)                                                           GPB0C405.69    
      {                                                                    GPB0C405.70    
        printf("C I/O Error: failed in BUFFIN32\n");                       GPB0C405.71    
        printf("Return code = %d\n",k);                                    GPB0C405.72    
        *status=1.0;                                                       GPB0C405.73    
*ENDIF                                                                     GPB0C405.74    
      }                                                                    GPB0C405.75    
    }                                                                      GPB0C405.76    
    else                                                                   GPB0C405.77    
      *status=3.0;                                                         GPB0C405.78    
}                                                                          GPB0C405.79    
                                                                           GPB0C405.80    
void                                                                       GBC2C405.84    
*IF DEF,C_LOW                                                              TS140793.71    
buffin8                                                                    TS140793.72    
*ELSEIF DEF,C_LOW_U                                                        TS140793.73    
buffin8_                                                                   TS140793.74    
*ELSE                                                                      TS140793.75    
BUFFIN8                                                                    TS140793.76    
*ENDIF                                                                     TS140793.77    
*IF DEF,CRAY                                                               GBC1C404.1     
(unit, f_array, maxlen, length, status)                                    GBC1C404.2     
*ELSE                                                                      GBC1C404.3     
(unit, array, maxlen, length, status)                                      TS140793.78    
*ENDIF                                                                     GBC1C404.4     
integer *unit;     /* Fortran unit                         */              GPB0C305.99    
*IF DEF,CRAY                                                               GBC1C404.5     
_fcd f_array; /* Array into which data is read        */                   GJC0F405.33    
*ELSE                                                                      GBC1C404.7     
char array[];      /* Array into which data is read        */              GPB0C305.100   
*ENDIF                                                                     GBC1C404.8     
integer *maxlen;   /* Number of bytes to be read           */              GPB0C305.101   
integer *length;   /* Number of bytes actually read        */              GPB0C305.102   
real *status;      /* Return code                          */              GPB0C305.103   
{                                                                          AD110293.238   
int k;                                                                     AD110293.239   
*IF DEF,CRAY                                                               GBC1C404.9     
char *array;                                                               GBC1C404.10    
                                                                           GBC1C404.11    
  array=__fcdtocp(f_array);                                                GBC1C404.12    
*ENDIF                                                                     GBC1C404.13    
                                                                           AD110293.240   
*IF DEF,CRI_FFIO                                                           GBC0C402.181   
  if(open_flag[*unit]== 0){                                                GBC0C402.182   
    *length = ffread(fd[*unit], array, *maxlen);                           GBC0C402.183   
                                                                           GBC0C402.184   
        *status=-1.0;                                                      GBC0C402.185   
    if(*length == -1)                                                      GBC0C402.186   
    {                                                                      GBC0C402.187   
      k=errno;                                                             GBC0C402.188   
      printf("C I/O Error: failed in BUFFIN8\n");                          GBC0C402.189   
      printf("Return code = %d\n",k);                                      GBC0C402.190   
      if(k == FFEOF || k == FFEOD)                                         GBC0C402.191   
      {                                                                    GBC0C402.192   
        *status=0.0;                                                       GBC0C402.193   
      }                                                                    GBC0C402.194   
      if(k == FFEOR)                                                       GBC0C402.195   
      {                                                                    GBC0C402.196   
        *status=1.0;                                                       GBC0C402.197   
      }                                                                    GBC0C402.198   
      if(k == FFERR)                                                       GBC0C402.199   
      {                                                                    GBC0C402.200   
        *status=2.0;                                                       GBC0C402.201   
      }                                                                    GBC0C402.202   
    }                                                                      GBC0C402.203   
   }                                                                       GBC0C402.204   
*ELSE                                                                      GBC0C402.205   
  if(open_flag[*unit]== 0){                                                AD110293.241   
    *length = fread(array,1,*maxlen,pf[*unit]);                            AD110293.242   
                                                                           AD110293.243   
        *status=-1.0;                                                      AD110293.244   
        k=feof(pf[*unit]);                                                 AD110293.245   
    if(k != 0)                                                             TS210793.38    
    {                                                                      TS210793.39    
      printf("C I/O Error: failed in BUFFIN8\n");                          TS210793.40    
      printf("Return code = %d\n",k);                                      TS210793.41    
      *status=0.0;                                                         TS210793.42    
    }                                                                      TS210793.43    
        k=ferror(pf[*unit]);                                               AD110293.247   
    if(k != 0)                                                             TS210793.44    
    {                                                                      TS210793.45    
      printf("C I/O Error: failed in BUFFIN8\n");                          TS210793.46    
      printf("Return code = %d\n",k);                                      TS210793.47    
      *status=1.0;                                                         TS210793.48    
    }                                                                      TS210793.49    
   }                                                                       AD110293.249   
*ENDIF                                                                     GBC0C402.206   
   else                                                                    AD110293.250   
        *status=3.0;                                                       AD110293.251   
                                                                           AD110293.252   
}                                                                          AD110293.253   
                                                                           AD110293.254   
void                                                                       GBC2C405.85    
*IF DEF,C_LOW                                                              TS140793.79    
buffou8                                                                    TS140793.80    
*ELSEIF DEF,C_LOW_U                                                        TS140793.81    
buffou8_                                                                   TS140793.82    
*ELSE                                                                      TS140793.83    
BUFFOU8                                                                    TS140793.84    
*ENDIF                                                                     TS140793.85    
*IF DEF,CRAY                                                               GBC1C404.14    
(unit, f_array, maxlen, length, status)                                    GBC1C404.15    
*ELSE                                                                      GBC1C404.16    
(unit, array, maxlen, length, status)                                      TS140793.86    
*ENDIF                                                                     GBC1C404.17    
integer *unit;     /* Fortran unit                            */           GPB0C305.104   
*IF DEF,CRAY                                                               GBC1C404.18    
_fcd f_array; /* Array into which data is read        */                   GJC0F405.34    
*ELSE                                                                      GBC1C404.20    
char   array[];    /* Array from which data is written        */           GPB0C305.105   
*ENDIF                                                                     GBC1C404.21    
integer *maxlen;   /* Number of bytes to be written           */           GPB0C305.106   
integer *length;   /* Number of bytes actually written        */           GPB0C305.107   
real *status;      /* Return code                             */           GPB0C305.108   
{                                                                          AD110293.261   
int k;                                                                     AD110293.262   
*IF DEF,CRAY                                                               GBC1C404.22    
char *array;                                                               GBC1C404.23    
                                                                           GBC1C404.24    
  array=__fcdtocp(f_array);                                                GBC1C404.25    
*ENDIF                                                                     GBC1C404.26    
                                                                           AD110293.263   
*IF DEF,CRI_FFIO                                                           GBC0C402.207   
  if(open_flag[*unit]== 0){                                                GBC0C402.208   
    *length = ffwrite(fd[*unit], array, *maxlen);                          GBC0C402.209   
                                                                           GBC0C402.210   
        *status=-1.0;                                                      GBC0C402.211   
    if(*length == -1)                                                      GBC0C402.212   
    {                                                                      GBC0C402.213   
      k=errno;                                                             GBC0C402.214   
      printf("C I/O Error: failed in BUFFOU8\n");                          GBC0C402.215   
      printf("Return code = %d\n",k);                                      GBC0C402.216   
      if(k == FFEOF || k == FFEOD)                                         GBC0C402.217   
      {                                                                    GBC0C402.218   
        *status=0.0;                                                       GBC0C402.219   
      }                                                                    GBC0C402.220   
      if(k == FFEOR)                                                       GBC0C402.221   
      {                                                                    GBC0C402.222   
        *status=1.0;                                                       GBC0C402.223   
      }                                                                    GBC0C402.224   
      if(k == FFERR)                                                       GBC0C402.225   
      {                                                                    GBC0C402.226   
        *status=2.0;                                                       GBC0C402.227   
      }                                                                    GBC0C402.228   
    }                                                                      GBC0C402.229   
   }                                                                       GBC0C402.230   
*ELSE                                                                      GBC0C402.231   
  if(open_flag[*unit]== 0){                                                AD110293.264   
    *length = fwrite(array,1,*maxlen,pf[*unit]);                           AD110293.265   
                                                                           AD110293.266   
        *status=-1.0;                                                      AD110293.267   
        k=feof(pf[*unit]);                                                 AD110293.268   
    if(k != 0)                                                             TS210793.50    
    {                                                                      TS210793.51    
      printf("C I/O Error: failed in BUFFOU8\n");                          TS210793.52    
      printf("Return code = %d\n",k);                                      TS210793.53    
      *status=0.0;                                                         TS210793.54    
    }                                                                      TS210793.55    
        k=ferror(pf[*unit]);                                               AD110293.270   
    if(k != 0)                                                             TS210793.56    
    {                                                                      TS210793.57    
      printf("C I/O Error: failed in BUFFOU8\n");                          TS210793.58    
      printf("Return code = %d\n",k);                                      TS210793.59    
      *status=1.0;                                                         TS210793.60    
    }                                                                      TS210793.61    
   }                                                                       AD110293.272   
*ENDIF                                                                     GBC0C402.232   
   else                                                                    AD110293.273   
        *status=3.0;                                                       AD110293.274   
                                                                           AD110293.275   
}                                                                          AD110293.276   
void                                                                       GBC2C405.86    
*IF DEF,C_LOW                                                              TS140793.87    
setpos8                                                                    TS140793.88    
*ELSEIF DEF,C_LOW_U                                                        TS140793.89    
setpos8_                                                                   TS140793.90    
*ELSE                                                                      TS140793.91    
SETPOS8                                                                    TS140793.92    
*ENDIF                                                                     TS140793.93    
(unit, byte_address)                                                       TS140793.94    
integer *unit;     /* Fortran unit                         */              GPB0C305.109   
integer *byte_address; /* Number of bytes into file            */          GBC2C405.87    
{                                                                          AD110293.280   
int k;                                                                     AD110293.281   
                                                                           AD110293.282   
*IF DEF,CRI_FFIO                                                           GBC0C402.233   
    k = ffseek(fd[*unit], *byte_address, SEEK_SET);                        GBC0C402.234   
    if(k < 0){                                                             GBC0C402.235   
      k=errno;                                                             GBC0C402.236   
      printf("ERROR detected in SETPOS\n");                                GBC0C402.237   
      printf("word_address = %d\n", (int) *byte_address);                  GBC2C405.88    
      printf("Return code from fseek = %d\n",k);                           GBC0C402.239   
    }                                                                      GBC0C402.240   
*ELSE                                                                      GBC0C402.241   
    k = fseek(pf[*unit],*byte_address,SEEK_SET);                           AD110293.283   
    if(k!=0){                                                              AD110293.284   
         printf("ERROR detected in SETPOS\n");                             AD110293.285   
         printf("word_address = %d\n", (int) *byte_address);               GBC2C405.89    
         printf("Return code from fseek = %d\n",k);                        GBC2C405.90    
    }                                                                      AD110293.288   
*ENDIF                                                                     GBC0C402.242   
}                                                                          AD110293.289   
                                                                           AD110293.290   
void                                                                       GBC2C405.91    
*IF DEF,C_LOW                                                              TS140793.95    
getpos8                                                                    TS140793.96    
*ELSEIF DEF,C_LOW_U                                                        TS140793.97    
getpos8_                                                                   TS140793.98    
*ELSE                                                                      TS140793.99    
GETPOS8                                                                    TS140793.100   
*ENDIF                                                                     TS140793.101   
(unit, byte_address)                                                       TS140793.102   
integer *unit;     /* Fortran unit                         */              GPB0C305.111   
integer *byte_address; /* Number of bytes into file            */          GBC2C405.92    
{                                                                          AD110293.294   
                                                                           AD110293.295   
*IF DEF,CRI_FFIO                                                           GBC0C402.243   
    printf("Illegal Call to GETPOS8 for Unit %d\n",*unit);                 GBC0C402.244   
    abort();                                                               GBC0C402.245   
*ELSE                                                                      GBC0C402.246   
    *byte_address = ftell(pf[*unit]);                                      AD110293.296   
*ENDIF                                                                     GBC0C402.247   
                                                                           GBC0C402.248   
                                                                           AD110293.297   
}                                                                          AD110293.298   
void                                                                       GPB0C405.87    
*IF DEF,C_LOW                                                              GPB0C405.88    
setpos32                                                                   GPB0C405.89    
*ELSEIF DEF,C_LOW_U                                                        GPB0C405.90    
setpos32_                                                                  GPB0C405.91    
*ELSE                                                                      GPB0C405.92    
SETPOS32                                                                   GPB0C405.93    
*ENDIF                                                                     GPB0C405.94    
(unit,word32_address,err)                                                  GPB0C405.95    
                                                                           GPB0C405.96    
integer *unit;            /* Fortran unit                         */       GPB0C405.97    
integer *word32_address;  /* Number of 32bit words into the file  */       GPB0C405.98    
integer *err;             /* 0: no error                                   GPB0C405.99    
                             1: error occured                     */       GPB0C405.100   
                                                                           GPB0C405.101   
{                                                                          GPB0C405.102   
int k;                                                                     GPB0C405.103   
integer byte_address;                                                      GPB0C405.104   
                                                                           GPB0C405.105   
  *err=0;                                                                  GPB0C405.106   
  if (open_flag[*unit]==0) {                                               GPB0C405.107   
    byte_address=(*word32_address)*4;                                      GPB0C405.108   
                                                                           GPB0C405.109   
*IF DEF,CRI_FFIO                                                           GPB0C405.110   
    k=ffseek(fd[*unit],byte_address,SEEK_SET);                             GPB0C405.111   
*ELSE                                                                      GPB0C405.112   
    k=fseek(pf[*unit],byte_address,SEEK_SET);                              GPB0C405.113   
*ENDIF                                                                     GPB0C405.114   
                                                                           GPB0C405.115   
    if (k != 0) {                                                          GPB0C405.116   
      k=errno;                                                             GPB0C405.117   
      perror("\nSETPOS32: Seek failed");                                   GPB0C405.118   
      sprintf(message,                                                     GPB0C405.119   
        "SETPOS32: Unit %d to 32bit Word Address %d failed. Error: %d",    GPB0C405.120   
        (int) *unit, (int) *word32_address, k);                            GPB0C405.121   
      the_unit=unit;                                                       GPB0C405.122   
      CALL_MESSAGE_PRINT(message);                                         GPB0C405.123   
      *err=1;                                                              GPB0C405.124   
      abort();                                                             GPB0C405.125   
    }                                                                      GPB0C405.126   
                                                                           GPB0C405.127   
  }                                                                        GPB0C405.128   
}                                                                          GPB0C405.129   
                                                                           GPB0C405.130   
void                                                                       GPB0C405.131   
*IF DEF,C_LOW                                                              GPB0C405.132   
getpos32                                                                   GPB0C405.133   
*ELSEIF DEF,C_LOW_U                                                        GPB0C405.134   
getpos32_                                                                  GPB0C405.135   
*ELSE                                                                      GPB0C405.136   
GETPOS32                                                                   GPB0C405.137   
*ENDIF                                                                     GPB0C405.138   
(unit,word32_address)                                                      GPB0C405.139   
                                                                           GPB0C405.140   
integer *unit;            /* Fortran unit                         */       GPB0C405.141   
integer *word32_address;  /* Number of 32bit words into the file  */       GPB0C405.142   
                                                                           GPB0C405.143   
{                                                                          GPB0C405.144   
int byte_address;                                                          GPB0C405.145   
                                                                           GPB0C405.146   
  if (open_flag[*unit]==0) {                                               GPB0C405.147   
*IF DEF,CRI_FFIO                                                           GPB0C405.148   
    printf("Illegal Call to GETPOS8 for Unit %d\n",*unit);                 GPB0C405.149   
    abort();                                                               GPB0C405.150   
*ELSE                                                                      GPB0C405.151   
    byte_address=ftell(pf[*unit]);                                         GPB0C405.152   
    *word32_address = byte_address/4;                                      GPB0C405.153   
*ENDIF                                                                     GPB0C405.154   
  }                                                                        GPB0C405.155   
}                                                                          GPB0C405.156   
                                                                           AD110293.299   
void                                                                       GBC2C405.93    
*IF DEF,C_LOW                                                              TS140793.103   
getpos                                                                     TS140793.104   
*ELSEIF DEF,C_LOW_U                                                        TS140793.105   
getpos_                                                                    TS140793.106   
*ELSE                                                                      TS140793.107   
GETPOS                                                                     TS140793.108   
*ENDIF                                                                     TS140793.109   
(unit, word_address)                                                       TS140793.110   
integer *unit;     /* Fortran unit                         */              GPB0C305.113   
integer *word_address; /* Number of words into file            */          GBC2C405.94    
{                                                                          AD110293.303   
long byte_address;                                                         AD110293.304   
                                                                           AD110293.305   
   the_unit=unit;                                                          GBC6C404.551   
*IF DEF,CRI_FFIO                                                           GBC0C402.249   
    *word_address = io_position[*unit];                                    GBC6C404.552   
/*   sprintf(message,                                                      GBC6C404.553   
    "GETPOS: Illegal Call to GETPOS for Unit %d", (int) *unit);            GBC6C404.554   
   CALL_MESSAGE_PRINT(message); */                                         GBC6C404.555   
*ELSE                                                                      GBC0C402.252   
     byte_address = ftell(pf[*unit]);                                      AD110293.306   
    *word_address = byte_address/sizeof(real);                             GPB0C305.79    
*ENDIF                                                                     GBC0C402.253   
      if(*word_address != io_position[*unit]) {                            GBC6C404.556   
        sprintf(message,                                                   GBC6C404.557   
         "GETPOS: IO_POSITION is %d, but FTELL gives %d",                  GBC6C404.558   
         (int) io_position[*unit], (int) *word_address);                   GBC6C404.559   
        the_unit=unit;                                                     GBC6C404.560   
        CALL_MESSAGE_PRINT(message);                                       GBC6C404.561   
        abort();                                                           GBC6C404.562   
      }                                                                    GBC6C404.563   
                                                                           AD110293.308   
}                                                                          AD110293.309   
                                                                           AD110293.310   
void                                                                       GBC2C405.95    
*IF DEF,C_LOW                                                              TS140793.111   
word_length                                                                TS140793.112   
*ELSEIF DEF,C_LOW_U                                                        TS140793.113   
word_length_                                                               TS140793.114   
*ELSE                                                                      TS140793.115   
WORD_LENGTH                                                                TS140793.116   
*ENDIF                                                                     TS140793.117   
(length)                                                                   TS140793.118   
integer *length;  /* Word length used by hardware         */               GPB0C305.115   
{                                                                          AD110293.313   
                                                                           AD110293.314   
    *length=sizeof(real);                                                  GPB0C305.116   
                                                                           AD110293.316   
}                                                                          AD110293.317   
void                                                                       GBC2C405.96    
*IF DEF,C_LOW                                                              TS140793.119   
get_file                                                                   TS140793.120   
*ELSEIF DEF,C_LOW_U                                                        TS140793.121   
get_file_                                                                  TS140793.122   
*ELSE                                                                      TS140793.123   
GET_FILE                                                                   TS140793.124   
*ENDIF                                                                     TS140793.125   
*IF DEF,CRAY                                                               GBC0C402.13    
(unit,f_filename,file_len,err)                                             GTD0C400.13    
_fcd f_filename; /* File name                           */                 GPB0C305.119   
*ELSE                                                                      GPB0C305.120   
(unit,filename,file_len,err)                                               GTD0C400.14    
char filename[]; /* File name                           */                 GPB0C305.122   
*ENDIF                                                                     GPB0C305.123   
integer *file_len; /* Dimension of filename               */               GPB0C305.124   
integer  *unit;    /* Fortran unit number                 */               GPB0C305.125   
integer  *err; /* Error checking err = 0 no errors, err = 1 errors */      GBC2C405.97    
{                                                                          AD050293.255   
char fname[16];                                                            GBC3C405.9     
char fno[4];                                                               UIE0C404.4     
char *gname;                                                               AD050293.258   
int i;                                                                     AD050293.259   
int k;                                                                     AD050293.260   
*IF DEF,CRAY                                                               GBC0C402.14    
char *filename;                                                            GPB0C305.127   
*ENDIF                                                                     GPB0C305.128   
                                                                           AD050293.261   
the_unit=unit;                                                             GBC6C404.564   
*IF DEF,CRAY                                                               GBC0C402.15    
filename=__fcdtocp(f_filename);                                            GPB0C305.130   
*ENDIF                                                                     GPB0C305.131   
/* construct environment variable name         */                          AD050293.262   
/* in form UNITnn, where nn is Fortran unit no */                          AD050293.263   
                                                                           AD050293.264   
       if ( *unit < 100){                                                  UIE0C404.5     
       strcpy (fname, "UNIT");                                             GTS2C304.3     
       sprintf(fno,"%02i", (int) *unit);                                   GBC2C405.98    
       strcat(fname,fno);                                                  AD050293.271   
       fname[6]='\0';                                                      AD050293.272   
       }                                                                   UIE0C404.6     
       else{                                                               UIE0C404.7     
       strcpy (fname, "UNIT");                                             UIE0C404.8     
       sprintf(fno,"%03i", (int) *unit);                                   GBC2C405.99    
       strcat(fname,fno);                                                  UIE0C404.10    
       fname[7]='\0';                                                      UIE0C404.11    
       }                                                                   UIE0C404.12    
                                                                           AD050293.273   
/* get file name stored in environment variable UNITnn */                  AD050293.274   
       gname=getenv(fname);                                                AD050293.275   
       if ( gname == NULL) {                                               GPB0C401.26    
         sprintf(message,                                                  GBC6C404.565   
          "GET_FILE: Environment Variable %s not Set", fname);             GBC6C404.566   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.567   
         filename[0] = '\0';                                               GPB0C401.29    
         for (i=1; i<*file_len; i++){                                      GPB0C401.30    
                filename[i] = ' ';                                         GBC6C404.568   
         }                                                                 GPB0C401.32    
         return;                                                           GPB0C401.33    
       }                                                                   GPB0C401.34    
       k=strlen(gname);                                                    AD050293.276   
       if(k >  *file_len){                                                 AD050293.277   
         sprintf(message,                                                  GBC6C404.569   
          "GET_FILE: File Name too long for Allocated Storage");           GBC6C404.570   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.571   
         sprintf(message,                                                  GBC6C404.572   
          "GET_FILE: Environment Variable %s", fname);                     GBC6C404.573   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.574   
         sprintf(message,                                                  GBC6C404.575   
          "GET_FILE: File Name %s", gname);                                GBC6C404.576   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.577   
         *err = 1;                                                         GTD0C400.16    
         abort();                                                          AD050293.282   
       }                                                                   AD050293.283   
                                                                           AD050293.284   
/* convert file name to Fortran format */                                  AD050293.285   
          *err = 0;                                                        GTD0C400.17    
          strncpy(filename,gname,k);                                       AD050293.286   
          for (i=k; i<*file_len; i++){                                     AD050293.287   
               filename[i] = ' ';                                          AD050293.288   
           }                                                               AD050293.289   
                                                                           AD050293.290   
                                                                           AD050293.291   
}                                                                          AD050293.292   
void                                                                       GBC2C405.100   
*IF DEF,C_LOW_U                                                            TS140793.127   
abort_()                                                                   TS140793.128   
*ELSE                                                                      TS140793.129   
*IF DEF,CRAY_MSG                                                           GBC0C402.297   
ABORT(_fcd f_msg)                                                          GBC0C402.298   
*ELSE                                                                      GBC0C402.299   
ABORT()                                                                    TS140793.130   
*ENDIF                                                                     GBC0C402.300   
*ENDIF                                                                     TS140793.131   
{                                                                          TS140793.132   
*IF DEF,CRAY_MSG                                                           GBC0C402.301   
  char *msg=__fcdtocp(f_msg);                                              GBC0C402.302   
  int msg_len=__fcdlen(f_msg);                                             GBC0C402.303   
  char ch_msg[msg_len+1];                                                  GBC0C402.304   
  integer *unit, *iostat;                                                  GBC0C402.305   
  integer six=6, zero;                                                     GBC0C402.306   
                                                                           GBC0C402.307   
  unit=&six;                                                               GBC0C402.308   
  iostat=&zero;                                                            GBC0C402.309   
  FLUSH(unit, iostat);                                                     GBC0C402.310   
  if(*iostat != 0)                                                         GBC0C402.311   
  {                                                                        GBC0C402.312   
  fprintf(stderr,                                                          GBC2C405.124   
   "\nUM_ABORT: Return Value from FLUSH was %d\n", (int) *iostat);         GBC6C404.579   
  }                                                                        GBC0C402.314   
                                                                           GBC0C402.315   
  strncpy(ch_msg, msg, msg_len);                                           GBC0C402.316   
  ch_msg[msg_len]='\0';                                                    GBC0C402.317   
  printf("\nUM ABORT: %s\n", ch_msg);                                      GBC0C402.318   
*ENDIF                                                                     GBC0C402.319   
  abort();                                                                 TS140793.133   
}                                                                          TS140793.134   
     /*          Force i/o buffer to be written to file */                 RR041093.3     
     /*          explicitly to prevent continuation run */                 RR041093.4     
     /*          problems following 'hard' failures.    */                 RR041093.5     
void                                                                       GBC2C405.101   
*IF DEF,C_LOW                                                              RR041093.6     
flush_buffer                                                               RR041093.7     
*ELSEIF DEF,C_LOW_U                                                        RR041093.8     
flush_buffer_                                                              RR041093.9     
*ELSE                                                                      RR041093.10    
FLUSH_BUFFER                                                               RR041093.11    
*ENDIF                                                                     RR041093.12    
(unit, icode)                                                              RR041093.13    
integer  *unit     ;  /* Fortran unit number             */                GBC2C405.102   
integer  *icode    ;  /* Integer return code             */                GBC2C405.103   
{                                                                          RR041093.16    
int  i         ;                                                           RR041093.17    
*IF DEF,CRI_FFIO                                                           GBC0C402.254   
  if(open_flag[*unit]== 0){                                                GBC0C402.255   
      i =   ffflush(fd[*unit]);                                            GBC0C402.256   
      *icode = i;                                                          GBC0C402.257   
  }                                                                        GBC0C402.258   
*ELSE                                                                      GBC0C402.259   
  if(open_flag[*unit]== 0){                                                GBC6C404.580   
      i =   fflush(pf[*unit]);                                             RR041093.18    
      *icode = i;                                                          RR041093.19    
  }                                                                        GBC6C404.581   
  else {                                                                   GBC6C404.582   
    if(pf[*unit] != NULL) {                                                GBC6C404.583   
      sprintf(message,                                                     GBC6C404.584   
       "FLUSH_BUFFER: File Pointer for Unopened Unit %d is %16X",          GBC6C404.585   
       (int) *unit, (unsigned long) pf[*unit]);                            GBC6C404.586   
      the_unit=unit;                                                       GBC6C404.587   
      CALL_MESSAGE_PRINT(message);                                         GBC6C404.588   
      abort();                                                             GBC6C404.589   
    }                                                                      GBC6C404.590   
  }                                                                        GBC6C404.591   
*ENDIF                                                                     GBC0C402.260   
}                                                                          RR041093.20    
void                                                                       GBC2C405.104   
*IF DEF,C_LOW                                                              GPB0C305.188   
fort_get_env                                                               GPB0C305.189   
*ELSEIF DEF,C_LOW_U                                                        GPB0C305.190   
fort_get_env_                                                              GPB0C305.191   
*ELSE                                                                      GPB0C305.192   
FORT_GET_ENV                                                               GPB0C305.193   
*ENDIF                                                                     GPB0C305.194   
*IF DEF,CRAY                                                               GBC0C402.16    
(f_env_var_name,ev_len,f_ev_contents,cont_len,ret_code)                    GPB0C401.36    
_fcd f_env_var_name; /* Name of environment variable   */                  GBC2C405.105   
integer *ev_len;     /* length of name                 */                  GBC2C405.106   
_fcd f_ev_contents;  /* contents of environment variable */                GBC2C405.107   
*ELSE                                                                      GPB0C401.40    
(env_var_name,ev_len,ev_contents,cont_len,ret_code)                        GPB0C305.195   
char *env_var_name;  /* Name of environment variable   */                  GPB0C305.196   
integer *ev_len;     /* length of name                 */                  GBC2C405.108   
char *ev_contents;   /* contents of environment variable */                GPB0C305.198   
*ENDIF                                                                     GPB0C401.41    
integer *cont_len;   /* length of contents              */                 GBC2C405.109   
integer *ret_code;   /* return code: 0=OK  -1=problems  */                 GBC2C405.110   
                                                                           GPB0C305.201   
{                                                                          GPB0C305.202   
        integer minus_one=-1;                                              GBC3C405.10    
                                                                           GPB0C305.203   
*IF DEF,CRAY                                                               GBC0C402.17    
        char *env_var_name=__fcdtocp(f_env_var_name);                      GPB0C401.43    
        char *ev_contents=__fcdtocp(f_ev_contents);                        GPB0C401.44    
*ENDIF                                                                     GPB0C401.45    
        char *c_env_var_name;                                              PXPORTIO.15    
                                                                           GBC3C405.12    
        char *value;                                                       GBC3C405.13    
        int len,i;                                                         GBC3C405.14    
                                                                           GBC3C405.15    
        c_env_var_name = calloc(*ev_len + 1, 1);                           PXPORTIO.16    
        the_unit=&minus_one;                                               GBC3C405.16    
        strncpy(c_env_var_name,env_var_name,*ev_len);                      GBC3C405.17    
        c_env_var_name[*ev_len]='\0';                                      GBC3C405.18    
        sscanf(c_env_var_name,"%s",c_env_var_name);                        GBC3C405.19    
                                                                           GBC3C405.20    
        value=getenv(c_env_var_name);                                      GBC3C405.21    
        if (value==NULL){                                                  GBC3C405.22    
          *ret_code=-1;                                                    GBC3C405.23    
          free( c_env_var_name );                                          PXPORTIO.17    
          return;}                                                         GBC3C405.24    
        else{                                                              GBC3C405.25    
          *ret_code=0;}                                                    GBC3C405.26    
                                                                           GBC3C405.27    
        len=strlen(value);                                                 GBC3C405.28    
        if (len > *cont_len){                                              GBC3C405.29    
         sprintf(message,                                                  GBC6C404.594   
          "FORT_GET_ENV: Value too long for Allocated Storage");           GBC6C404.595   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.596   
         sprintf(message,                                                  GBC6C404.597   
          "FORT_GET_ENV: Environment Variable %s",                         GBC6C404.598   
          c_env_var_name);                                                 GBC6C404.599   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.600   
         sprintf(message,                                                  GBC6C404.601   
          "FORT_GET_ENV: Value %s", value);                                GBC6C404.602   
         CALL_MESSAGE_PRINT(message);                                      GBC6C404.603   
                abort();                                                   GBC3C405.30    
        }                                                                  GBC3C405.31    
                                                                           GBC3C405.32    
        strncpy(ev_contents,value,len);                                    GBC3C405.33    
        for (i=len; i<*cont_len; i++){                                     GBC3C405.34    
                ev_contents[i]=' ';                                        GBC3C405.35    
        }                                                                  GBC3C405.36    
free( c_env_var_name );                                                    PXPORTIO.18    
                                                                           GBC3C405.37    
}                                                                          GPB0C305.234   
*IF DEF,CRI_FFIO                                                           GBC0C402.261   
                                                                           GBC0C402.262   
void                                                                       GBC2C405.111   
CLOSE_ALL_FILES                                                            GBC0C402.263   
()                                                                         GBC0C402.264   
{                                                                          GBC0C402.265   
integer minus_one=-1;                                                      GBC6C404.604   
  int unit, k;                                                             GBC0C402.266   
                                                                           GBC0C402.267   
    sprintf(message,                                                       GBC6C404.605   
     "\nCall to Close All Files");                                         GBC6C404.606   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.607   
    sprintf(message,                                                       GBC6C404.608   
     "-----------------------\n");                                         GBC6C404.609   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.610   
/* Loop over all known Units */                                            GBC0C402.270   
    for (unit=0; unit<MAX_UNITS; unit++)                                   GBC6C404.611   
    {                                                                      GBC0C402.272   
/* first check to see if unit has been closed already (or not opened)*/    GBC0C402.273   
        if(open_flag[unit]== 0)                                            GBC0C402.274   
        {                                                                  GBC0C402.275   
            the_unit=&minus_one;                                           GBC6C404.612   
/* close file */                                                           GBC0C402.276   
            k=ffclose(fd[unit]);                                           GBC0C402.277   
/* check the error response */                                             GBC0C402.278   
            if(k >= 0)                                                     GBC0C402.279   
            {                                                              GBC0C402.280   
/* set unit flag to closed */                                              GBC0C402.281   
                open_flag[unit]=1;                                         GBC0C402.282   
                sprintf(message,                                           GBC6C404.613   
                 "CLOSE: File on Unit %3d Closed", (int) unit);            GBC6C404.614   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.615   
            }                                                              GBC0C402.284   
/* file not closed */                                                      GBC0C402.285   
            else                                                           GBC0C402.286   
            {                                                              GBC0C402.287   
                sprintf(message,                                           GBC6C404.616   
                 "CLOSE: Cannot Close File on Unit %3d - Code = %d",       GBC6C404.617   
                 (int) unit, errno);                                       GBC6C404.618   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.619   
            }                                                              GBC0C402.290   
        }                                                                  GBC0C402.291   
    }                                                                      GBC0C402.292   
    sprintf(message, "\n");                                                GBC6C404.620   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.621   
}                                                                          GBC0C402.294   
void                                                                       GBC2C405.112   
FLUSH_ALL_FILES                                                            GBC0C403.1     
()                                                                         GBC0C403.2     
{                                                                          GBC0C403.3     
integer minus_one=-1;                                                      GBC6C404.622   
  int unit, k;                                                             GBC0C403.4     
                                                                           GBC0C403.5     
    sprintf(message,                                                       GBC6C404.623   
     "\nCall to Flush All Files");                                         GBC6C404.624   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.625   
    sprintf(message,                                                       GBC6C404.626   
     "-----------------------\n");                                         GBC6C404.627   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.628   
/* Loop over all known Units */                                            GBC0C403.8     
    for (unit=0; unit<MAX_UNITS; unit++)                                   GBC6C404.629   
    {                                                                      GBC0C403.10    
/* first check to see if unit has been Flushed already (or not opened)*/   GBC0C403.11    
        if(open_flag[unit]== 0)                                            GBC0C403.12    
        {                                                                  GBC0C403.13    
            the_unit=&minus_one;                                           GBC6C404.630   
/* Flush file */                                                           GBC0C403.14    
            k=ffflush(fd[unit]);                                           GBC0C403.15    
/* check the error response */                                             GBC0C403.16    
            if(k >= 0)                                                     GBC0C403.17    
            {                                                              GBC0C403.18    
/* set unit flag to Flushed */                                             GBC0C403.19    
                sprintf(message,                                           GBC6C404.631   
                 "FLUSH: File on Unit %3d Flushed", (int) unit);           GBC6C404.632   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.633   
            }                                                              GBC0C403.21    
/* file not flushed */                                                     GBC0C403.22    
            else                                                           GBC0C403.23    
            {                                                              GBC0C403.24    
                sprintf(message,                                           GBC6C404.634   
                 "FLUSH: Cannot Flush File on Unit %3d - Code = %d",       GBC6C404.635   
                 (int) unit, errno);                                       GBC6C404.636   
                CALL_MESSAGE_PRINT(message);                               GBC6C404.637   
            }                                                              GBC0C403.27    
        }                                                                  GBC0C403.28    
    }                                                                      GBC0C403.29    
    sprintf(message, "\n");                                                GBC6C404.638   
    CALL_MESSAGE_PRINT(message);                                           GBC6C404.639   
}                                                                          GBC0C403.31    
*ELSE                                                                      GBC0C403.32    
                                                                           GBC0C403.33    
void                                                                       GBC2C405.113   
CLOSE_ALL_FILES                                                            GBC0C403.34    
()                                                                         GBC0C403.35    
{                                                                          GBC0C403.36    
}                                                                          GBC0C403.37    
                                                                           GBC0C403.38    
void                                                                       GBC2C405.114   
FLUSH_ALL_FILES                                                            GBC0C403.39    
()                                                                         GBC0C403.40    
{                                                                          GBC0C403.41    
}                                                                          GBC0C403.42    
                                                                           GBC0C403.43    
*ENDIF                                                                     GBC0C402.295   
/*                                                              */         GBC6C404.640   
/* Entry to accept the current File length prior                */         GBC6C404.641   
/* to an open request                                           */         GBC6C404.642   
/*                                                              */         GBC6C404.643   
void                                                                       GBC6C404.644   
*IF DEF,C_LOW                                                              GBC6C404.645   
set_dumpfile_length                                                        GBC6C404.646   
*ELSEIF DEF,C_LOW_U                                                        GBC6C404.647   
set_dumpfile_length_                                                       GBC6C404.648   
*ELSE                                                                      GBC6C404.649   
SET_DUMPFILE_LENGTH                                                        GBC6C404.650   
*ENDIF                                                                     GBC6C404.651   
(unit, length)                                                             GBC6C404.652   
integer *unit;                                                             GBC6C404.653   
integer *length;                                                           GBC6C404.654   
{                                                                          GBC6C404.655   
*IF DEF,CRI_OPEN                                                           GBC6C404.656   
  file_size[*unit]=*length*sizeof(real);                                   GBC6C404.657   
*IF DEF,DIAG92                                                             GBC6C404.658   
  the_unit=unit;                                                           GBC6C404.659   
  sprintf(message,                                                         GBC6C404.660   
   "File Length for Unit %d set to %d Bytes",                              GBC6C404.661   
   (int) *unit, (int) file_size[*unit]);                                   GBC6C404.662   
  CALL_MESSAGE_PRINT(message);                                             GBC6C404.663   
*ENDIF                                                                     GBC6C404.664   
*ENDIF                                                                     GBC6C404.665   
}                                                                          GBC6C404.666   
void                                                                       GBC2C405.125   
*IF DEF,C_LOW                                                              GBC2C405.126   
clear_unit_bcast_flag                                                      GBC2C405.127   
*ELSEIF DEF,C_LOW_U                                                        GBC2C405.128   
clear_unit_bcast_flag_                                                     GBC2C405.129   
*ELSE                                                                      GBC2C405.130   
CLEAR_UNIT_BCAST_FLAG                                                      GBC2C405.131   
*ENDIF                                                                     GBC2C405.132   
(unit)                                                                     GBC2C405.133   
integer *unit;                                                             GBC2C405.134   
{                                                                          GBC2C405.135   
  integer minus_one=-1;                                                    GBC2C405.136   
                                                                           GBC2C405.137   
  file_properties[*unit]=(minus_one ^ BCAST) & file_properties[*unit];     GBC2C405.138   
                                                                           GBC2C405.139   
}                                                                          GBC2C405.140   
                                                                           GBC2C405.141   
void                                                                       GBC2C405.142   
*IF DEF,C_LOW                                                              GBC2C405.143   
set_unit_bcast_flag                                                        GBC2C405.144   
*ELSEIF DEF,C_LOW_U                                                        GBC2C405.145   
set_unit_bcast_flag_                                                       GBC2C405.146   
*ELSE                                                                      GBC2C405.147   
SET_UNIT_BCAST_FLAG                                                        GBC2C405.148   
*ENDIF                                                                     GBC2C405.149   
(unit)                                                                     GBC2C405.150   
integer *unit;                                                             GBC2C405.151   
{                                                                          GBC2C405.152   
                                                                           GBC2C405.153   
  file_properties[*unit]=BCAST | file_properties[*unit];                   GBC2C405.154   
                                                                           GBC2C405.155   
}                                                                          GBC2C405.156   
                                                                           GBC2C405.157   
                                                                           GBC2C405.158   
void                                                                       GBC2C405.159   
*IF DEF,C_LOW                                                              GBC2C405.160   
find_unit_bcast_flag                                                       GBC2C405.161   
*ELSEIF DEF,C_LOW_U                                                        GBC2C405.162   
find_unit_bcast_flag_                                                      GBC2C405.163   
*ELSE                                                                      GBC2C405.164   
FIND_UNIT_BCAST_FLAG                                                       GBC2C405.165   
*ENDIF                                                                     GBC2C405.166   
(unit, flag)                                                               GBC2C405.167   
integer *unit;                                                             GBC2C405.168   
integer *flag; /* non-zero if set, otherwise 0 */                          GBC2C405.169   
{                                                                          GBC2C405.170   
                                                                           GBC2C405.171   
  *flag=BCAST & file_properties[*unit];                                    GBC2C405.172   
                                                                           GBC2C405.173   
}                                                                          GBC2C405.174   
                                                                           GBC2C405.175   
                                                                           GBC0C402.296   
*ENDIF                                                                     PORTIO2A.279   
